<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Minecraft Clone</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;font-family:sans-serif;background:#87CEEB}
#game{width:100vw;height:100vh;display:block}
#crosshair{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:24px;pointer-events:none;text-shadow:0 0 2px #000;z-index:100}
#hotbar{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);display:flex;gap:2px;z-index:100}
.slot{width:50px;height:50px;background:rgba(0,0,0,0.6);border:2px solid #555;display:flex;align-items:center;justify-content:center}
.slot.selected{border-color:#fff;background:rgba(255,255,255,0.3)}
.slot canvas{width:40px;height:40px;image-rendering:pixelated}
#info{position:fixed;top:10px;left:10px;color:#fff;font-size:14px;text-shadow:0 0 2px #000;z-index:100;background:rgba(0,0,0,0.3);padding:10px;border-radius:5px}
#instructions{position:fixed;top:10px;right:10px;color:#fff;font-size:12px;text-shadow:0 0 2px #000;z-index:100;background:rgba(0,0,0,0.5);padding:10px;border-radius:5px}
#menu{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.85);color:#fff;padding:30px;border-radius:10px;text-align:center;z-index:200}
#menu h1{margin-bottom:20px}
#menu button{padding:15px 30px;font-size:18px;cursor:pointer;background:#4a4;border:none;color:#fff;border-radius:5px;margin:5px;min-width:200px}
#menu button:hover{background:#5b5}
#menu button.danger{background:#a44}
#menu button.danger:hover{background:#b55}
#menu p{margin-bottom:15px;opacity:0.8}
#saveStatus{position:fixed;bottom:70px;left:50%;transform:translateX(-50%);color:#fff;font-size:14px;text-shadow:0 0 2px #000;z-index:100;opacity:0;transition:opacity 0.3s}
#saveStatus.show{opacity:1}
</style>
</head>
<body>
<div id="menu">
    <h1>Minecraft Clone</h1>
    <p id="menuStatus">Loading...</p>
    <button id="playBtn" onclick="startGame()" style="display:none">Continue Playing</button>
    <button id="newWorldBtn" onclick="newWorld()" style="display:none" class="danger">New World</button>
</div>
<div id="crosshair">+</div>
<div id="hotbar"></div>
<div id="info">Loading...</div>
<div id="saveStatus">Saving...</div>
<div id="instructions">
<b>Controls:</b><br>
WASD - Move<br>
Space - Jump<br>
Shift - Sneak<br>
Mouse - Look<br>
Left Click - Break<br>
Right Click - Place<br>
1-9 - Select slot<br>
Scroll - Change slot<br>
<br><i>World auto-saves!</i>
</div>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const gl = canvas.getContext('webgl', {antialias: false});
const CHUNK_SIZE = 16;
const CHUNK_HEIGHT = 64;
const RENDER_DIST = 3;
const WATER_LEVEL = 14;

const BLOCKS = {
    AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, 
    LEAVES: 5, SAND: 6, WATER: 7, COBBLE: 8, PLANKS: 9
};

const BLOCK_NAMES = ['Air','Grass','Dirt','Stone','Wood','Leaves','Sand','Water','Cobblestone','Planks'];

const COLORS = {
    [BLOCKS.GRASS]: {top:[0.3,0.8,0.2], side:[0.55,0.4,0.25], bottom:[0.55,0.4,0.25]},
    [BLOCKS.DIRT]: {top:[0.55,0.4,0.25], side:[0.55,0.4,0.25], bottom:[0.55,0.4,0.25]},
    [BLOCKS.STONE]: {top:[0.5,0.5,0.5], side:[0.5,0.5,0.5], bottom:[0.5,0.5,0.5]},
    [BLOCKS.WOOD]: {top:[0.6,0.5,0.3], side:[0.45,0.3,0.15], bottom:[0.6,0.5,0.3]},
    [BLOCKS.LEAVES]: {top:[0.2,0.55,0.15], side:[0.2,0.55,0.15], bottom:[0.2,0.55,0.15]},
    [BLOCKS.SAND]: {top:[0.9,0.85,0.6], side:[0.9,0.85,0.6], bottom:[0.9,0.85,0.6]},
    [BLOCKS.WATER]: {top:[0.2,0.4,0.8], side:[0.2,0.4,0.8], bottom:[0.2,0.4,0.8]},
    [BLOCKS.COBBLE]: {top:[0.4,0.4,0.4], side:[0.4,0.4,0.4], bottom:[0.4,0.4,0.4]},
    [BLOCKS.PLANKS]: {top:[0.7,0.55,0.3], side:[0.7,0.55,0.3], bottom:[0.7,0.55,0.3]}
};

let worldSeed = 12345;
let perm = new Uint8Array(512);

function initNoise(seed) {
    const rand = () => { seed = (seed * 1103515245 + 12345) & 0x7fffffff; return seed / 0x7fffffff; };
    for (let i = 0; i < 256; i++) perm[i] = i;
    for (let i = 255; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
    }
    for (let i = 0; i < 256; i++) perm[i + 256] = perm[i];
}

function noise2D(x, y) {
    const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
    x -= Math.floor(x); y -= Math.floor(y);
    const u = x * x * (3 - 2 * x), v = y * y * (3 - 2 * y);
    const a = perm[X] + Y, b = perm[X + 1] + Y;
    return (1 - v) * ((1 - u) * (perm[a] & 15) + u * (perm[b] & 15)) / 15 +
           v * ((1 - u) * (perm[a + 1] & 15) + u * (perm[b + 1] & 15)) / 15;
}

function getHeight(wx, wz) {
    let h = noise2D(wx * 0.01, wz * 0.01) * 25 + noise2D(wx * 0.03, wz * 0.03) * 12 + noise2D(wx * 0.08, wz * 0.08) * 5;
    return Math.floor(h + 20);
}

let chunks = {};
let modifiedChunks = {};
let player = {x: 0, y: 50, z: 0, vx: 0, vy: 0, vz: 0, yaw: 0, pitch: 0, onGround: false};
let keys = {};
let selectedSlot = 0;
let inventory = [1, 2, 3, 4, 5, 6, 8, 9, 7];
let isLocked = false;
let lastTime = performance.now();
let fps = 0, frameCount = 0, fpsTime = 0;
let lastFootstep = 0;
let audioCtx = null;
let saveTimeout = null;
let worldLoaded = false;

// Storage functions
async function saveWorld() {
    try {
        showSaveStatus('Saving...');
        
        // Save seed and player
        await window.storage.set('mc_world', JSON.stringify({
            seed: worldSeed,
            player: { x: player.x, y: player.y, z: player.z, yaw: player.yaw, pitch: player.pitch },
            inventory: inventory,
            selectedSlot: selectedSlot
        }));
        
        // Save modified chunks
        for (const key in modifiedChunks) {
            if (modifiedChunks[key].needsSave) {
                await window.storage.set('mc_' + key, JSON.stringify(modifiedChunks[key].changes));
                modifiedChunks[key].needsSave = false;
            }
        }
        
        showSaveStatus('Saved!');
        setTimeout(() => showSaveStatus(''), 1500);
    } catch (e) {
        console.error('Save failed:', e);
        showSaveStatus('Save failed');
    }
}

async function loadWorld() {
    try {
        const data = await window.storage.get('mc_world');
        if (data && data.value) {
            const world = JSON.parse(data.value);
            worldSeed = world.seed;
            player.x = world.player.x;
            player.y = world.player.y;
            player.z = world.player.z;
            player.yaw = world.player.yaw || 0;
            player.pitch = world.player.pitch || 0;
            inventory = world.inventory || inventory;
            selectedSlot = world.selectedSlot || 0;
            initNoise(worldSeed);
            return true;
        }
    } catch (e) {
        console.log('No saved world found, creating new');
    }
    return false;
}

async function loadChunkModifications(cx, cz) {
    const key = cx + ',' + cz;
    if (modifiedChunks[key]) return modifiedChunks[key].changes;
    
    try {
        const data = await window.storage.get('mc_' + key);
        if (data && data.value) {
            const changes = JSON.parse(data.value);
            modifiedChunks[key] = { changes, needsSave: false };
            return changes;
        }
    } catch (e) {}
    return null;
}

function markChunkModified(cx, cz, lx, y, lz, blockType) {
    const key = cx + ',' + cz;
    if (!modifiedChunks[key]) {
        modifiedChunks[key] = { changes: {}, needsSave: true };
    }
    const blockKey = lx + ',' + y + ',' + lz;
    modifiedChunks[key].changes[blockKey] = blockType;
    modifiedChunks[key].needsSave = true;
    
    // Debounced save
    if (saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(saveWorld, 2000);
}

async function deleteWorld() {
    try {
        const keys = await window.storage.list('mc_');
        if (keys && keys.keys) {
            for (const key of keys.keys) {
                await window.storage.delete(key);
            }
        }
        await window.storage.delete('mc_world');
    } catch (e) {
        console.error('Delete failed:', e);
    }
}

function showSaveStatus(msg) {
    const el = document.getElementById('saveStatus');
    el.textContent = msg;
    el.className = msg ? 'show' : '';
}

function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playSound(type) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    osc.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    
    if (type === 'break') {
        osc.type = 'square'; osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
        filter.type = 'lowpass'; filter.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'place') {
        osc.type = 'square'; osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.05);
        filter.type = 'lowpass'; filter.frequency.setValueAtTime(1200, now);
        gain.gain.setValueAtTime(0.25, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.start(now); osc.stop(now + 0.08);
    } else if (type === 'step') {
        osc.type = 'triangle';
        const pitch = 80 + Math.random() * 40;
        osc.frequency.setValueAtTime(pitch, now);
        osc.frequency.exponentialRampToValueAtTime(pitch * 0.5, now + 0.06);
        filter.type = 'lowpass'; filter.frequency.setValueAtTime(600, now);
        gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.06);
        osc.start(now); osc.stop(now + 0.06);
    }
}

const vsSource = `
attribute vec3 aPos; attribute vec3 aColor; attribute vec3 aNormal;
uniform mat4 uMVP; varying vec3 vColor; varying float vFog;
void main() {
    gl_Position = uMVP * vec4(aPos, 1.0);
    float light = 0.5 + 0.5 * max(dot(aNormal, normalize(vec3(0.3, 1.0, 0.5))), 0.0);
    vColor = aColor * light; vFog = gl_Position.z / 80.0;
}`;

const fsSource = `
precision mediump float; varying vec3 vColor; varying float vFog;
void main() {
    vec3 fogColor = vec3(0.53, 0.81, 0.92);
    float f = clamp(vFog, 0.0, 1.0);
    gl_FragColor = vec4(mix(vColor, fogColor, f * f), 1.0);
}`;

function compileShader(type, src) {
    const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compileShader(gl.VERTEX_SHADER, vsSource));
gl.attachShader(prog, compileShader(gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(prog); gl.useProgram(prog);

const aPos = gl.getAttribLocation(prog, 'aPos');
const aColor = gl.getAttribLocation(prog, 'aColor');
const aNormal = gl.getAttribLocation(prog, 'aNormal');
const uMVP = gl.getUniformLocation(prog, 'uMVP');

gl.enable(gl.DEPTH_TEST); gl.enable(gl.CULL_FACE);

function chunkKey(cx, cz) { return cx + ',' + cz; }

async function generateChunk(cx, cz) {
    const blocks = new Uint8Array(CHUNK_SIZE * CHUNK_HEIGHT * CHUNK_SIZE);
    const treePositions = [];
    
    // Use seeded random for trees
    const treeSeed = (cx * 73856093) ^ (cz * 19349663) ^ worldSeed;
    const treeRand = (i) => {
        const n = Math.sin(treeSeed + i * 9999) * 43758.5453;
        return n - Math.floor(n);
    };
    
    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
        for (let lz = 0; lz < CHUNK_SIZE; lz++) {
            const wx = cx * CHUNK_SIZE + lx, wz = cz * CHUNK_SIZE + lz;
            const height = getHeight(wx, wz);
            
            for (let y = 0; y < CHUNK_HEIGHT; y++) {
                const idx = lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * CHUNK_HEIGHT;
                if (y === 0) blocks[idx] = BLOCKS.STONE;
                else if (y < height - 4) blocks[idx] = BLOCKS.STONE;
                else if (y < height - 1) blocks[idx] = BLOCKS.DIRT;
                else if (y === height - 1) blocks[idx] = height < WATER_LEVEL + 2 ? BLOCKS.SAND : BLOCKS.GRASS;
                else if (y < WATER_LEVEL) blocks[idx] = BLOCKS.WATER;
                else blocks[idx] = BLOCKS.AIR;
            }
            
            // Check for tree
            if (lx >= 2 && lx < CHUNK_SIZE - 2 && lz >= 2 && lz < CHUNK_SIZE - 2) {
                const treeChance = treeRand(lx * 16 + lz);
                if (height > WATER_LEVEL + 2 && treeChance < 0.008) {
                    treePositions.push({ lx, lz, height, h: 4 + Math.floor(treeRand(lx * 16 + lz + 1000) * 2) });
                }
            }
        }
    }
    
    // Add trees
    for (const tree of treePositions) {
        for (let ty = 0; ty < tree.h; ty++) {
            const y = tree.height + ty;
            if (y < CHUNK_HEIGHT) blocks[tree.lx + y * CHUNK_SIZE + tree.lz * CHUNK_SIZE * CHUNK_HEIGHT] = BLOCKS.WOOD;
        }
        for (let dx = -2; dx <= 2; dx++) {
            for (let dz = -2; dz <= 2; dz++) {
                for (let dy = -1; dy <= 2; dy++) {
                    const nx = tree.lx + dx, nz = tree.lz + dz, ny = tree.height + tree.h + dy;
                    if (nx >= 0 && nx < CHUNK_SIZE && nz >= 0 && nz < CHUNK_SIZE && ny < CHUNK_HEIGHT) {
                        const dist = Math.abs(dx) + Math.abs(dz) + Math.abs(dy);
                        const idx = nx + ny * CHUNK_SIZE + nz * CHUNK_SIZE * CHUNK_HEIGHT;
                        if (dist < 4 && blocks[idx] === BLOCKS.AIR) blocks[idx] = BLOCKS.LEAVES;
                    }
                }
            }
        }
    }
    
    // Apply saved modifications
    const mods = await loadChunkModifications(cx, cz);
    if (mods) {
        for (const key in mods) {
            const [lx, y, lz] = key.split(',').map(Number);
            blocks[lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * CHUNK_HEIGHT] = mods[key];
        }
    }
    
    return { cx, cz, blocks, mesh: null, dirty: true };
}

function getBlock(x, y, z) {
    if (y < 0 || y >= CHUNK_HEIGHT) return BLOCKS.AIR;
    const cx = Math.floor(x / CHUNK_SIZE), cz = Math.floor(z / CHUNK_SIZE);
    const chunk = chunks[chunkKey(cx, cz)];
    if (!chunk) return BLOCKS.AIR;
    const lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    return chunk.blocks[lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * CHUNK_HEIGHT];
}

function setBlock(x, y, z, type) {
    if (y < 0 || y >= CHUNK_HEIGHT) return;
    const cx = Math.floor(x / CHUNK_SIZE), cz = Math.floor(z / CHUNK_SIZE);
    const chunk = chunks[chunkKey(cx, cz)];
    if (!chunk) return;
    const lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    chunk.blocks[lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * CHUNK_HEIGHT] = type;
    chunk.dirty = true;
    
    // Mark as modified for persistence
    markChunkModified(cx, cz, lx, y, lz, type);
    
    if (lx === 0) { const c = chunks[chunkKey(cx-1, cz)]; if(c) c.dirty = true; }
    if (lx === CHUNK_SIZE-1) { const c = chunks[chunkKey(cx+1, cz)]; if(c) c.dirty = true; }
    if (lz === 0) { const c = chunks[chunkKey(cx, cz-1)]; if(c) c.dirty = true; }
    if (lz === CHUNK_SIZE-1) { const c = chunks[chunkKey(cx, cz+1)]; if(c) c.dirty = true; }
}

function buildMesh(chunk) {
    const positions = [], colors = [], normals = [];
    
    const faces = [
        {dir: [0, 1, 0], corners: [[0,1,0],[0,1,1],[1,1,1],[1,1,0]], face: 'top', ao: [[[-1,1,0],[0,1,-1],[-1,1,-1]], [[-1,1,0],[0,1,1],[-1,1,1]], [[1,1,0],[0,1,1],[1,1,1]], [[1,1,0],[0,1,-1],[1,1,-1]]]},
        {dir: [0, -1, 0], corners: [[0,0,1],[0,0,0],[1,0,0],[1,0,1]], face: 'bottom', ao: [[[-1,-1,0],[0,-1,1],[-1,-1,1]], [[-1,-1,0],[0,-1,-1],[-1,-1,-1]], [[1,-1,0],[0,-1,-1],[1,-1,-1]], [[1,-1,0],[0,-1,1],[1,-1,1]]]},
        {dir: [0, 0, 1], corners: [[0,0,1],[1,0,1],[1,1,1],[0,1,1]], face: 'side', ao: [[[-1,0,1],[0,-1,1],[-1,-1,1]], [[1,0,1],[0,-1,1],[1,-1,1]], [[1,0,1],[0,1,1],[1,1,1]], [[-1,0,1],[0,1,1],[-1,1,1]]]},
        {dir: [0, 0, -1], corners: [[1,0,0],[0,0,0],[0,1,0],[1,1,0]], face: 'side', ao: [[[1,0,-1],[0,-1,-1],[1,-1,-1]], [[-1,0,-1],[0,-1,-1],[-1,-1,-1]], [[-1,0,-1],[0,1,-1],[-1,1,-1]], [[1,0,-1],[0,1,-1],[1,1,-1]]]},
        {dir: [1, 0, 0], corners: [[1,0,1],[1,0,0],[1,1,0],[1,1,1]], face: 'side', ao: [[[1,0,1],[1,-1,0],[1,-1,1]], [[1,0,-1],[1,-1,0],[1,-1,-1]], [[1,0,-1],[1,1,0],[1,1,-1]], [[1,0,1],[1,1,0],[1,1,1]]]},
        {dir: [-1, 0, 0], corners: [[0,0,0],[0,0,1],[0,1,1],[0,1,0]], face: 'side', ao: [[[-1,0,-1],[-1,-1,0],[-1,-1,-1]], [[-1,0,1],[-1,-1,0],[-1,-1,1]], [[-1,0,1],[-1,1,0],[-1,1,1]], [[-1,0,-1],[-1,1,0],[-1,1,-1]]]}
    ];
    
    const isSolid = (x, y, z) => { const b = getBlock(x, y, z); return b !== BLOCKS.AIR && b !== BLOCKS.WATER && b !== BLOCKS.LEAVES; };
    const calcAO = (s1, s2, c) => (s1 && s2) ? 0 : 3 - (s1 + s2 + c);
    
    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
        for (let y = 0; y < CHUNK_HEIGHT; y++) {
            for (let lz = 0; lz < CHUNK_SIZE; lz++) {
                const block = chunk.blocks[lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * CHUNK_HEIGHT];
                if (block === BLOCKS.AIR || block === BLOCKS.WATER) continue;
                
                const wx = chunk.cx * CHUNK_SIZE + lx, wz = chunk.cz * CHUNK_SIZE + lz;
                const color = COLORS[block];
                
                for (const f of faces) {
                    const neighbor = getBlock(wx + f.dir[0], y + f.dir[1], wz + f.dir[2]);
                    if (neighbor === BLOCKS.AIR || neighbor === BLOCKS.WATER || (neighbor === BLOCKS.LEAVES && block !== BLOCKS.LEAVES)) {
                        const c = color[f.face] || color.side;
                        const aoValues = f.ao.map(aoData => {
                            const s1 = isSolid(wx + aoData[0][0], y + aoData[0][1], wz + aoData[0][2]) ? 1 : 0;
                            const s2 = isSolid(wx + aoData[1][0], y + aoData[1][1], wz + aoData[1][2]) ? 1 : 0;
                            const cn = isSolid(wx + aoData[2][0], y + aoData[2][1], wz + aoData[2][2]) ? 1 : 0;
                            return calcAO(s1, s2, cn);
                        });
                        
                        const indices = (aoValues[0] + aoValues[2] > aoValues[1] + aoValues[3]) ? [0,1,2,0,2,3] : [1,2,3,1,3,0];
                        for (const i of indices) {
                            const corner = f.corners[i];
                            positions.push(wx + corner[0], y + corner[1], wz + corner[2]);
                            const aoFactor = 0.55 + (aoValues[i] / 3) * 0.45;
                            colors.push(c[0] * aoFactor, c[1] * aoFactor, c[2] * aoFactor);
                            normals.push(f.dir[0], f.dir[1], f.dir[2]);
                        }
                    }
                }
            }
        }
    }
    
    // Water
    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
        for (let y = 0; y < CHUNK_HEIGHT; y++) {
            for (let lz = 0; lz < CHUNK_SIZE; lz++) {
                if (chunk.blocks[lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * CHUNK_HEIGHT] !== BLOCKS.WATER) continue;
                const wx = chunk.cx * CHUNK_SIZE + lx, wz = chunk.cz * CHUNK_SIZE + lz;
                if (getBlock(wx, y + 1, wz) === BLOCKS.AIR) {
                    const c = COLORS[BLOCKS.WATER].top;
                    for (const i of [0,1,2,0,2,3]) {
                        const corner = [[0,0.9,0],[0,0.9,1],[1,0.9,1],[1,0.9,0]][i];
                        positions.push(wx + corner[0], y + corner[1], wz + corner[2]);
                        colors.push(c[0], c[1], c[2]);
                        normals.push(0, 1, 0);
                    }
                }
            }
        }
    }
    
    if (positions.length === 0) return null;
    
    const vb = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vb); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
    const cb = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, cb); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    const nb = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, nb); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    
    return { vb, cb, nb, count: positions.length / 3 };
}

function perspective(fov, aspect, near, far) {
    const f = 1 / Math.tan(fov / 2), nf = 1 / (near - far);
    return [f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,2*far*near*nf,0];
}

function multiply(a, b) {
    const r = new Array(16).fill(0);
    for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) for (let k = 0; k < 4; k++) r[j*4+i] += a[k*4+i] * b[j*4+k];
    return r;
}

function rotateX(m, a) { const c = Math.cos(a), s = Math.sin(a); return multiply(m, [1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]); }
function rotateY(m, a) { const c = Math.cos(a), s = Math.sin(a); return multiply(m, [c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]); }
function translate(m, x, y, z) { return multiply(m, [1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]); }

let chunkLoadQueue = [];

async function updateChunks() {
    const pcx = Math.floor(player.x / CHUNK_SIZE), pcz = Math.floor(player.z / CHUNK_SIZE);
    
    for (let dx = -RENDER_DIST; dx <= RENDER_DIST; dx++) {
        for (let dz = -RENDER_DIST; dz <= RENDER_DIST; dz++) {
            const key = chunkKey(pcx + dx, pcz + dz);
            if (!chunks[key] && !chunkLoadQueue.includes(key)) {
                chunkLoadQueue.push(key);
            }
        }
    }
    
    // Load one chunk per frame
    if (chunkLoadQueue.length > 0) {
        const key = chunkLoadQueue.shift();
        const [cx, cz] = key.split(',').map(Number);
        if (!chunks[key]) {
            chunks[key] = await generateChunk(cx, cz);
        }
    }
    
    for (const key in chunks) {
        const c = chunks[key];
        if (Math.abs(c.cx - pcx) > RENDER_DIST + 1 || Math.abs(c.cz - pcz) > RENDER_DIST + 1) {
            if (c.mesh) { gl.deleteBuffer(c.mesh.vb); gl.deleteBuffer(c.mesh.cb); gl.deleteBuffer(c.mesh.nb); }
            delete chunks[key];
        } else if (c.dirty) {
            if (c.mesh) { gl.deleteBuffer(c.mesh.vb); gl.deleteBuffer(c.mesh.cb); gl.deleteBuffer(c.mesh.nb); }
            c.mesh = buildMesh(c);
            c.dirty = false;
        }
    }
}

function collides(x, y, z) {
    const w = 0.3, h = 1.8;
    for (let dx = -1; dx <= 1; dx++) {
        for (let dy = 0; dy <= 2; dy++) {
            for (let dz = -1; dz <= 1; dz++) {
                const bx = Math.floor(x + dx * w), by = Math.floor(y + dy * h / 2), bz = Math.floor(z + dz * w);
                const b = getBlock(bx, by, bz);
                if (b !== BLOCKS.AIR && b !== BLOCKS.WATER) {
                    if (x + w > bx && x - w < bx + 1 && y + h > by && y < by + 1 && z + w > bz && z - w < bz + 1) return true;
                }
            }
        }
    }
    return false;
}

function updatePlayer(dt) {
    const speed = keys.ShiftLeft ? 3 : 6;
    let mx = 0, mz = 0;
    
    if (keys.KeyW) { mx -= Math.sin(player.yaw); mz -= Math.cos(player.yaw); }
    if (keys.KeyS) { mx += Math.sin(player.yaw); mz += Math.cos(player.yaw); }
    if (keys.KeyA) { mx -= Math.cos(player.yaw); mz += Math.sin(player.yaw); }
    if (keys.KeyD) { mx += Math.cos(player.yaw); mz -= Math.sin(player.yaw); }
    
    const len = Math.sqrt(mx * mx + mz * mz);
    if (len > 0) { mx /= len; mz /= len; }
    
    const accel = player.onGround ? 15 : 4;
    player.vx += (mx * speed - player.vx) * accel * dt;
    player.vz += (mz * speed - player.vz) * accel * dt;
    player.vy -= 28 * dt;
    
    if (keys.Space && player.onGround) { player.vy = 9; player.onGround = false; }
    
    const nx = player.x + player.vx * dt;
    if (!collides(nx, player.y, player.z)) player.x = nx; else player.vx = 0;
    
    const nz = player.z + player.vz * dt;
    if (!collides(player.x, player.y, nz)) player.z = nz; else player.vz = 0;
    
    // Footsteps
    const moving = Math.abs(player.vx) > 0.5 || Math.abs(player.vz) > 0.5;
    const now = performance.now();
    if (player.onGround && moving && now - lastFootstep > (keys.ShiftLeft ? 450 : 320)) {
        playSound('step'); lastFootstep = now;
    }
    
    const ny = player.y + player.vy * dt;
    if (!collides(player.x, ny, player.z)) { player.y = ny; player.onGround = false; }
    else { if (player.vy < 0) player.onGround = true; player.vy = 0; }
    
    if (player.y < -20) { player.y = 50; player.vy = 0; }
}

function raycast(maxDist) {
    const dx = -Math.sin(player.yaw) * Math.cos(player.pitch);
    const dy = Math.sin(player.pitch);
    const dz = -Math.cos(player.yaw) * Math.cos(player.pitch);
    let x = player.x, y = player.y + 1.6, z = player.z;
    let prevX = Math.floor(x), prevY = Math.floor(y), prevZ = Math.floor(z);
    
    for (let i = 0; i < maxDist * 50; i++) {
        x += dx * 0.02; y += dy * 0.02; z += dz * 0.02;
        const bx = Math.floor(x), by = Math.floor(y), bz = Math.floor(z);
        if (bx !== prevX || by !== prevY || bz !== prevZ) {
            const b = getBlock(bx, by, bz);
            if (b !== BLOCKS.AIR && b !== BLOCKS.WATER) return { x: bx, y: by, z: bz, px: prevX, py: prevY, pz: prevZ, block: b };
            prevX = bx; prevY = by; prevZ = bz;
        }
    }
    return null;
}

function render() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.53, 0.81, 0.92, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
    const proj = perspective(Math.PI / 2.5, canvas.width / canvas.height, 0.1, 500);
    let view = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
    view = rotateX(view, -player.pitch);
    view = rotateY(view, -player.yaw);
    view = translate(view, -player.x, -player.y - 1.6, -player.z);
    gl.uniformMatrix4fv(uMVP, false, multiply(proj, view));
    
    for (const key in chunks) {
        const c = chunks[key];
        if (!c.mesh) continue;
        gl.bindBuffer(gl.ARRAY_BUFFER, c.mesh.vb); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, c.mesh.cb); gl.enableVertexAttribArray(aColor); gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, c.mesh.nb); gl.enableVertexAttribArray(aNormal); gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, c.mesh.count);
    }
}

function createHotbar() {
    const hotbar = document.getElementById('hotbar');
    hotbar.innerHTML = '';
    for (let i = 0; i < 9; i++) {
        const slot = document.createElement('div');
        slot.className = 'slot' + (i === selectedSlot ? ' selected' : '');
        const type = inventory[i];
        if (type && COLORS[type]) {
            const cv = document.createElement('canvas'); cv.width = 16; cv.height = 16;
            const ctx = cv.getContext('2d');
            const col = COLORS[type].top;
            ctx.fillStyle = `rgb(${col[0]*255|0},${col[1]*255|0},${col[2]*255|0})`;
            ctx.fillRect(2, 2, 12, 8);
            const side = COLORS[type].side;
            ctx.fillStyle = `rgb(${side[0]*180|0},${side[1]*180|0},${side[2]*180|0})`;
            ctx.fillRect(2, 10, 12, 4);
            slot.appendChild(cv);
        }
        hotbar.appendChild(slot);
    }
}

function updateInfo() {
    document.getElementById('info').innerHTML = `FPS: ${fps}<br>X: ${player.x.toFixed(1)} Y: ${player.y.toFixed(1)} Z: ${player.z.toFixed(1)}<br>Block: ${BLOCK_NAMES[inventory[selectedSlot]]}`;
}

function spawnPlayer() {
    player.x = 8; player.z = 8;
    player.y = getHeight(8, 8) + 2;
}

function gameLoop(time) {
    const dt = Math.min((time - lastTime) / 1000, 0.05);
    lastTime = time;
    frameCount++;
    if (time - fpsTime > 1000) { fps = frameCount; frameCount = 0; fpsTime = time; }
    
    if (isLocked) updatePlayer(dt);
    updateChunks();
    render();
    updateInfo();
    requestAnimationFrame(gameLoop);
}

async function startGame() {
    document.getElementById('menu').style.display = 'none';
    canvas.requestPointerLock();
    if (!worldLoaded) {
        await initWorld(false);
        worldLoaded = true;
    }
}

async function newWorld() {
    if (!confirm('Delete your current world and start fresh?')) return;
    
    document.getElementById('menuStatus').textContent = 'Creating new world...';
    document.getElementById('playBtn').style.display = 'none';
    document.getElementById('newWorldBtn').style.display = 'none';
    
    await deleteWorld();
    
    // Reset state
    chunks = {};
    modifiedChunks = {};
    chunkLoadQueue = [];
    worldSeed = Math.floor(Math.random() * 2147483647);
    initNoise(worldSeed);
    spawnPlayer();
    player.yaw = 0; player.pitch = 0;
    player.vx = 0; player.vy = 0; player.vz = 0;
    
    await saveWorld();
    worldLoaded = true;
    
    document.getElementById('menu').style.display = 'none';
    canvas.requestPointerLock();
}

async function initWorld(isInit = true) {
    const hasWorld = await loadWorld();
    
    if (!hasWorld) {
        worldSeed = Math.floor(Math.random() * 2147483647);
        initNoise(worldSeed);
        spawnPlayer();
    }
    
    // Pre-generate spawn chunks
    const pcx = Math.floor(player.x / CHUNK_SIZE), pcz = Math.floor(player.z / CHUNK_SIZE);
    for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
            const key = chunkKey(pcx + dx, pcz + dz);
            if (!chunks[key]) chunks[key] = await generateChunk(pcx + dx, pcz + dz);
        }
    }
    
    if (isInit) {
        document.getElementById('menuStatus').textContent = hasWorld ? 'World loaded!' : 'New world created!';
        document.getElementById('playBtn').textContent = hasWorld ? 'Continue Playing' : 'Start Playing';
        document.getElementById('playBtn').style.display = 'block';
        document.getElementById('newWorldBtn').style.display = 'block';
    }
}

canvas.addEventListener('click', () => { if (!isLocked) canvas.requestPointerLock(); });

document.addEventListener('pointerlockchange', () => {
    isLocked = document.pointerLockElement === canvas;
    document.getElementById('menu').style.display = isLocked ? 'none' : 'block';
    if (!isLocked && worldLoaded) saveWorld();
});

document.addEventListener('mousemove', e => {
    if (!isLocked) return;
    player.yaw += e.movementX * 0.002;
    player.pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, player.pitch - e.movementY * 0.002));
});

document.addEventListener('mousedown', e => {
    if (!isLocked) return;
    initAudio();
    const hit = raycast(5);
    
    if (e.button === 0 && hit) {
        setBlock(hit.x, hit.y, hit.z, BLOCKS.AIR);
        playSound('break');
    } else if (e.button === 2 && hit) {
        const px = hit.px, py = hit.py, pz = hit.pz;
        const w = 0.3, h = 1.8;
        const blockOverlaps = !(player.x + w < px || player.x - w > px + 1 || player.y + h < py || player.y > py + 1 || player.z + w < pz || player.z - w > pz + 1);
        if (!blockOverlaps) { setBlock(px, py, pz, inventory[selectedSlot]); playSound('place'); }
    }
});

document.addEventListener('contextmenu', e => e.preventDefault());
document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code >= 'Digit1' && e.code <= 'Digit9') { selectedSlot = parseInt(e.code[5]) - 1; createHotbar(); }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });
document.addEventListener('wheel', e => { selectedSlot = ((selectedSlot + (e.deltaY > 0 ? 1 : -1)) % 9 + 9) % 9; createHotbar(); });

// Auto-save periodically
setInterval(() => { if (worldLoaded && Object.keys(modifiedChunks).some(k => modifiedChunks[k].needsSave)) saveWorld(); }, 30000);

// Initialize
createHotbar();
initWorld(true);
requestAnimationFrame(gameLoop);
</script>
</body>
</html>