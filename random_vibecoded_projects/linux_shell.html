<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebTerm</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg-color: rgba(13, 17, 23, 0.75); /* Semi-transparent for 3D bg */
            --text-color: #c9d1d9;
            --prompt-user: #58a6ff;
            --prompt-host: #79c0ff;
            --prompt-dir: #d2a8ff;
            --cmd-color: #7ee787;
            --error-color: #ff7b72;
            --dir-color: #79c0ff;
            --file-color: #c9d1d9;
            --symlink-color: #56d364;
            --muted: #8b949e;
            --header-color: #f0f6fc;
            --font-stack: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        * {
            box-sizing: border-box;
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: transparent; /* Changed from #000 to transparent */
            color: var(--text-color);
            font-family: var(--font-stack);
            font-size: 14px;
            overflow: hidden;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(to bottom, #a8c0ff, #3f2b96); /* Fallback gradient */
        }

        #terminal-container {
            width: 100%;
            height: 100%;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-color);
            position: relative;
            z-index: 1;
            text-shadow: 0px 1px 2px rgba(0,0,0,0.8); /* Drop shadow for readability */
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(13, 17, 23, 0.5);
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(48, 54, 61, 0.8);
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(72, 79, 88, 0.9);
        }

        .output-line {
            margin-bottom: 2px;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.4;
        }

        .input-line {
            display: flex;
            align-items: center;
            margin-top: 5px;
        }

        .prompt {
            white-space: nowrap;
            margin-right: 8px;
            text-shadow: 0px 1px 3px rgba(0,0,0,1);
        }

        .prompt span.user { color: var(--prompt-user); font-weight: bold; }
        .prompt span.at { color: var(--text-color); }
        .prompt span.host { color: var(--prompt-host); font-weight: bold; }
        .prompt span.sep { color: var(--text-color); }
        .prompt span.dir { color: var(--prompt-dir); font-weight: bold; }
        .prompt span.symbol { color: var(--text-color); }

        #cmd-input {
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: var(--font-stack);
            font-size: 14px;
            flex-grow: 1;
            outline: none;
            caret-color: var(--text-color);
            text-shadow: 0px 1px 2px rgba(0,0,0,0.8);
        }

        /* Colors for ls output */
        .ls-dir { color: var(--dir-color); font-weight: bold; }
        .ls-file { color: var(--file-color); }
        .ls-exec { color: #7ee787; font-weight: bold; }
        .ls-symlink { color: var(--symlink-color); font-style: italic; }
        
        /* ls -l formatting */
        .ls-l-row { display: grid; grid-template-columns: 80px 40px 80px 80px 60px 120px auto; gap: 10px; }

        .boot-msg { color: var(--muted); }
        .boot-success { color: var(--cmd-color); }
        .boot-error { color: var(--error-color); }
        .man-header { color: var(--header-color); font-weight: bold; text-decoration: underline;}

        /* ASCII Art */
        .ascii-art {
            color: var(--prompt-dir);
            font-weight: bold;
            margin-bottom: 10px;
            white-space: pre;
        }
    </style>
</head>
<body>
    <!-- 3D Background Canvas Container -->
    <div id="canvas-container"></div>

    <div id="terminal-container" onclick="focusInput()">
        <div id="output"></div>
        <div class="input-line" id="input-area" style="display:none;">
            <div class="prompt" id="prompt-label">
                <!-- Prompt generated by JS -->
            </div>
            <input type="text" id="cmd-input" autocomplete="off" spellcheck="false">
        </div>
    </div>

    <script>
        // --- THREE.JS BACKGROUND ---
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            // Soft blue fog like the sky in the painting
            scene.fog = new THREE.FogExp2(0xdcebf7, 0.02);
            scene.background = new THREE.Color(0xdcebf7);

            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 12);
            camera.lookAt(0, 2, 0);

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffeebb, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // --- OBJECTS ---

            // 1. Water Plane
            const waterGeo = new THREE.PlaneGeometry(100, 100);
            const waterMat = new THREE.MeshStandardMaterial({ 
                color: 0xaaddff, 
                roughness: 0.1, 
                metalness: 0.1,
                transparent: true,
                opacity: 0.8
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.receiveShadow = true;
            scene.add(water);

            // 2. Island (Flattened Sphere)
            const islandGeo = new THREE.SphereGeometry(3, 32, 16);
            const islandMat = new THREE.MeshStandardMaterial({ color: 0x5c7c35, roughness: 0.8 }); // Mossy green
            const island = new THREE.Mesh(islandGeo, islandMat);
            island.scale.set(1, 0.3, 1);
            island.position.y = -0.2; // Just peeking out of water
            island.castShadow = true;
            island.receiveShadow = true;
            scene.add(island);

            // 3. Tree Group
            const treeGroup = new THREE.Group();
            scene.add(treeGroup);

            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.5, 2.5, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.9 }); // Dark brown
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.25;
            trunk.castShadow = true;
            
            // Create a slight bend in trunk by adding a second segment or rotating
            trunk.rotation.z = 0.1;
            treeGroup.add(trunk);

            // Branches (Simple cylinders)
            const branchMat = trunkMat;
            const b1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.2, 1.5), branchMat);
            b1.position.set(0.5, 2.2, 0);
            b1.rotation.z = -0.8;
            treeGroup.add(b1);

            const b2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.2, 1.2), branchMat);
            b2.position.set(-0.4, 2.0, 0.2);
            b2.rotation.z = 0.8;
            b2.rotation.y = 0.5;
            treeGroup.add(b2);

            // Cherry Blossom Canopy (Particles)
            const particleCount = 3500;
            const particlesGeo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const colorObj = new THREE.Color();

            for(let i=0; i<particleCount; i++) {
                // Create a cloud shape around the top of the tree
                // Random point in sphere, then flatten/stretch
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = Math.cbrt(Math.random()) * 2.8; // Radius

                let x = r * Math.sin(phi) * Math.cos(theta);
                let y = r * Math.sin(phi) * Math.sin(theta) * 0.6; // Flatten Y
                let z = r * Math.cos(phi);

                // Move to top of tree
                y += 3.0;
                x += (Math.random() - 0.5) * 0.5; // Jitter

                positions.push(x, y, z);

                // Colors: Pink, Dark Pink, White mix
                const hue = 0.9 + Math.random() * 0.1; // Pink/Red range
                const sat = 0.6 + Math.random() * 0.4;
                const light = 0.5 + Math.random() * 0.3;
                colorObj.setHSL(hue, sat, light);
                colors.push(colorObj.r, colorObj.g, colorObj.b);
            }

            particlesGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particlesGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const particlesMat = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                opacity: 0.9,
                transparent: true,
                sizeAttenuation: true
            });

            const canopy = new THREE.Points(particlesGeo, particlesMat);
            treeGroup.add(canopy);

            // Fallen petals on water/island
            const petalsGeo = new THREE.BufferGeometry();
            const petalPos = [];
            const petalCols = [];
            for(let i=0; i<200; i++) {
                const r = Math.sqrt(Math.random()) * 4;
                const theta = Math.random() * 2 * Math.PI;
                const x = r * Math.cos(theta);
                const z = r * Math.sin(theta);
                const y = 0.05; // Just above water
                petalPos.push(x, y, z);
                colorObj.setHSL(0.95, 0.8, 0.7);
                petalCols.push(colorObj.r, colorObj.g, colorObj.b);
            }
            petalsGeo.setAttribute('position', new THREE.Float32BufferAttribute(petalPos, 3));
            petalsGeo.setAttribute('color', new THREE.Float32BufferAttribute(petalCols, 3));
            const petals = new THREE.Points(petalsGeo, new THREE.PointsMaterial({size: 0.1, vertexColors: true}));
            scene.add(petals);


            // Animation Loop
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.001;

                // Rotate camera slowly around center
                const radius = 14;
                camera.position.x = Math.sin(time) * radius;
                camera.position.z = Math.cos(time) * radius;
                camera.lookAt(0, 2, 0);

                // Gentle wave movement on water (simulated by moving island slightly or just mental projection)
                // Actually let's just bob the tree slightly
                treeGroup.position.y = Math.sin(time * 3) * 0.05;

                renderer.render(scene, camera);
            }

            animate();

            // Handle Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Initialize 3D Scene on load
        window.addEventListener('load', initThreeJS);


        // --- VIRTUAL FILE SYSTEM ---
        class FileSystem {
            constructor() {
                const now = new Date();
                const dateStr = now.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });

                this.root = {
                    type: 'dir',
                    perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr,
                    children: {
                        'bin': { type: 'dir', perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr, children: {} }, // populated dynamically in help
                        'boot': { type: 'dir', perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr, children: {
                            'vmlinuz': { type: 'file', perms: '-rwxr-xr-x', user: 'root', group: 'root', size: 8388608, date: dateStr, content: '[BINARY DATA]' }
                        }},
                        'dev': { type: 'dir', perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr, children: {
                            'null': { type: 'file', perms: 'crw-rw-rw-', user: 'root', group: 'root', size: 0, date: dateStr, content: '' },
                            'zero': { type: 'file', perms: 'crw-rw-rw-', user: 'root', group: 'root', size: 0, date: dateStr, content: '' },
                            'random': { type: 'file', perms: 'crw-rw-rw-', user: 'root', group: 'root', size: 0, date: dateStr, content: '' }
                        }},
                        'etc': { type: 'dir', perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr, children: {
                            'passwd': { type: 'file', perms: '-rw-r--r--', user: 'root', group: 'root', size: 1024, date: dateStr, content: 'root:x:0:0:root:/root:/bin/bash\nguest:x:1000:1000:Guest User:/home/guest:/bin/bash' },
                            'hostname': { type: 'file', perms: '-rw-r--r--', user: 'root', group: 'root', size: 12, date: dateStr, content: 'webterm' },
                            'issue': { type: 'file', perms: '-rw-r--r--', user: 'root', group: 'root', size: 24, date: dateStr, content: 'WebTerm Linux 1.0 \\n \\l' },
                            'os-release': { type: 'file', perms: '-rw-r--r--', user: 'root', group: 'root', size: 256, date: dateStr, content: 'NAME="WebTerm Linux"\nVERSION="1.0 (HTML5 Edition)"\nID=webterm\nPRETTY_NAME="WebTerm Linux v1.0"' }
                        }},
                        'home': {
                            type: 'dir', perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr,
                            children: {
                                'guest': {
                                    type: 'dir', perms: 'drwxr-xr-x', user: 'guest', group: 'guest', size: 4096, date: dateStr,
                                    children: {
                                        'projects': {
                                            type: 'dir', perms: 'drwxr-xr-x', user: 'guest', group: 'guest', size: 4096, date: dateStr,
                                            children: {
                                                'webterm.js': { type: 'file', perms: '-rw-r--r--', user: 'guest', group: 'guest', size: 1234, date: dateStr, content: 'console.log("Hello World");' },
                                                'todo.txt': { type: 'file', perms: '-rw-r--r--', user: 'guest', group: 'guest', size: 45, date: dateStr, content: '- Buy milk\n- Hack the planet\n- Learn React\n- Sleep' },
                                                'app.py': { type: 'file', perms: '-rwxr-xr-x', user: 'guest', group: 'guest', size: 512, date: dateStr, content: 'print("Starting server...")\nimport http.server' }
                                            }
                                        },
                                        'readme.txt': { type: 'file', perms: '-rw-r--r--', user: 'guest', group: 'guest', size: 320, date: dateStr, content: 'Welcome to WebTerm v1.0.\n\nThis is a fully functional terminal simulator running in your browser.\nTry generic unix commands like ls, cd, cat, mkdir, touch, rm, cp, mv, grep, etc.' },
                                        'secret.txt': { type: 'file', perms: '-rw-------', user: 'guest', group: 'guest', size: 32, date: dateStr, content: 'The password is: javascript_rules' },
                                        '.bashrc': { type: 'file', perms: '-rw-r--r--', user: 'guest', group: 'guest', size: 120, date: dateStr, content: 'alias ll="ls -la"\nexport PATH=$PATH:/home/guest/bin' }
                                    }
                                }
                            }
                        },
                        'proc': { type: 'dir', perms: 'dr-xr-xr-x', user: 'root', group: 'root', size: 0, date: dateStr, children: {
                            'cpuinfo': { type: 'file', perms: '-r--r--r--', user: 'root', group: 'root', size: 0, date: dateStr, content: 'processor\t: 0\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel name\t: Virtual Web CPU @ 2.50GHz' },
                            'meminfo': { type: 'file', perms: '-r--r--r--', user: 'root', group: 'root', size: 0, date: dateStr, content: 'MemTotal:        8192000 kB\nMemFree:         4096000 kB' },
                            'version': { type: 'file', perms: '-r--r--r--', user: 'root', group: 'root', size: 0, date: dateStr, content: 'Linux version 5.4.0-webterm (gcc version 9.3.0) #1 SMP' }
                        }},
                        'root': { type: 'dir', perms: '-rw-r-----', user: 'root', group: 'root', size: 4096, date: dateStr, children: {} },
                        'tmp': { type: 'dir', perms: 'drwxrwxrwt', user: 'root', group: 'root', size: 4096, date: dateStr, children: {} },
                        'usr': { type: 'dir', perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr, children: {
                            'bin': { type: 'dir', perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr, children: {} },
                            'lib': { type: 'dir', perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr, children: {} }
                        }},
                        'var': { type: 'dir', perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr, children: { 
                            'log': { type: 'dir', perms: 'drwxr-xr-x', user: 'root', group: 'root', size: 4096, date: dateStr, children: {
                                'syslog': { type: 'file', perms: '-rw-r-----', user: 'syslog', group: 'adm', size: 10240, date: dateStr, content: 'Nov 21 10:00:01 webterm systemd[1]: Started Session 1 of user guest.\nNov 21 10:00:02 webterm kernel: [    0.000000] Linux version 5.4.0-webterm' }
                            }} 
                        }}
                    }
                };
                this.currentPath = ['home', 'guest'];
            }

            resolve(pathStr) {
                let parts;
                let current;

                if (pathStr === '/') {
                    return { node: this.root, pathArr: [], name: '/' };
                }

                if (pathStr.startsWith('/')) {
                    parts = pathStr.split('/').filter(p => p.length > 0);
                    current = this.root;
                } else {
                    parts = [...this.currentPath, ...pathStr.split('/')].filter(p => p.length > 0);
                    current = this.root;
                }

                // Handle .. and .
                const resolvedParts = [];
                for (const p of parts) {
                    if (p === '..') {
                        if (resolvedParts.length > 0) resolvedParts.pop();
                    } else if (p !== '.') {
                        resolvedParts.push(p);
                    }
                }

                // Traverse
                for (const p of resolvedParts) {
                    if (current.type !== 'dir') return null; 
                    if (!current.children[p]) return null; 
                    current = current.children[p];
                }

                return { node: current, pathArr: resolvedParts, name: resolvedParts[resolvedParts.length - 1] || '/' };
            }

            getParent(pathStr) {
                let absParts;
                if (pathStr.startsWith('/')) {
                    absParts = pathStr.split('/').filter(p => p.length > 0);
                } else {
                    absParts = [...this.currentPath, ...pathStr.split('/')].filter(p => p.length > 0);
                }
                
                // Normalize
                const normParts = [];
                 for (const p of absParts) {
                    if (p === '..') {
                        if (normParts.length > 0) normParts.pop();
                    } else if (p !== '.') {
                        normParts.push(p);
                    }
                }

                if (normParts.length === 0) return { node: this.root, pathArr: [], name: '/' }; // Root parent is root
                const name = normParts.pop();
                const parentPath = '/' + normParts.join('/');
                return { parentRes: this.resolve(parentPath), childName: name };
            }
        }

        // --- TERMINAL ENGINE ---
        class Terminal {
            constructor() {
                this.fs = new FileSystem();
                this.user = 'guest';
                this.hostname = 'webterm';
                this.history = [];
                this.historyIndex = -1;
                this.startTime = new Date();
                
                this.outputEl = document.getElementById('output');
                this.inputArea = document.getElementById('input-area');
                this.inputEl = document.getElementById('cmd-input');
                this.promptLabel = document.getElementById('prompt-label');

                this.setupEvents();
                this.bootSequence();
            }

            setupEvents() {
                this.inputEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const cmd = this.inputEl.value;
                        this.execute(cmd);
                        this.inputEl.value = '';
                        this.historyIndex = -1;
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (this.history.length > 0) {
                            if (this.historyIndex < this.history.length - 1) {
                                this.historyIndex++;
                                this.inputEl.value = this.history[this.history.length - 1 - this.historyIndex];
                            }
                        }
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (this.historyIndex > 0) {
                            this.historyIndex--;
                            this.inputEl.value = this.history[this.history.length - 1 - this.historyIndex];
                        } else {
                            this.historyIndex = -1;
                            this.inputEl.value = '';
                        }
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        this.handleTabCompletion();
                    } else if (e.ctrlKey && e.key === 'l') {
                        e.preventDefault();
                        this.cmdClear();
                    }
                });
            }

            async bootSequence() {
                const msgs = [
                    "Loading kernel...",
                    "Uncompressing Linux... done, booting the kernel.",
                    "Mounting VFS...",
                    "Initializing cgroup subsys cpuset",
                    "Initializing cgroup subsys cpu",
                    "Initializing cgroup subsys cpuacct",
                    "Linux version 5.4.0-webterm (gcc version 9.3.0) #1 SMP",
                    "Command line: BOOT_IMAGE=/boot/vmlinuz ro quiet splash",
                    "Populating /dev fs",
                    "Writing superblocks and filesystem accounting information: done.",
                    "Starting System Logging Service...",
                    "Starting Network Manager...",
                    "Starting OpenBSD Secure Shell server...",
                    "Reached target Network is Online.",
                    "Reached target Multi-User System.",
                    "Welcome to WebTerm Linux 1.0"
                ];

                for (const msg of msgs) {
                    await new Promise(r => setTimeout(r, Math.random() * 200 + 50));
                    this.printLine(`[ <span class="boot-success">OK</span> ] ${msg}`, 'boot-msg');
                }
                await new Promise(r => setTimeout(r, 500));

                const art = `
 __      __      ___.    ___________                    
/  \\    /  \\ ____\\_ |__  \\__    ___/___ _______  _____  
\\   \\/\\/   // __ \\| __ \\   |    |_/ __ \\\\_  __ \\/     \\ 
 \\        /\\  ___/| \\_\\ \\  |    |\\  ___/ |  | \\/  Y Y  \\
  \\__/\\  /  \\___  >___  /  |____| \\___  >|__|  |__|_|  /
       \\/       \\/    \\/              \\/             \\/ `;
                
                this.printLine(art, 'ascii-art');
                this.printLine("Welcome to WebTerm v1.0. Type 'help' for commands.\n");
                
                this.inputArea.style.display = 'flex';
                this.updatePrompt();
                this.inputEl.focus();
            }

            updatePrompt() {
                const pathStr = '/' + this.fs.currentPath.join('/');
                const displayPath = pathStr.replace('/home/guest', '~');
                this.promptLabel.innerHTML = `<span class="user">${this.user}</span><span class="at">@</span><span class="host">${this.hostname}</span><span class="sep">:</span><span class="dir">${displayPath}</span><span class="symbol">$</span>`;
            }

            execute(cmdStr) {
                const trimmed = cmdStr.trim();
                const promptHTML = this.promptLabel.innerHTML;
                this.printLine(`${promptHTML} ${cmdStr}`);

                if (!trimmed) {
                    this.scrollToBottom();
                    return;
                }

                this.history.push(trimmed);

                // Better tokenizing for quotes
                const args = [];
                let current = '';
                let inQuote = false;
                for(let i=0; i<trimmed.length; i++) {
                    const char = trimmed[i];
                    if(char === '"' || char === "'") {
                        inQuote = !inQuote;
                    } else if (char === ' ' && !inQuote) {
                        if(current.length > 0) args.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                if(current.length > 0) args.push(current);

                const cmd = args[0];
                const params = args.slice(1);

                switch(cmd) {
                    case 'help': this.cmdHelp(); break;
                    case 'clear': this.cmdClear(); break;
                    case 'ls': this.cmdLs(params); break;
                    case 'cd': this.cmdCd(params); break;
                    case 'cat': this.cmdCat(params); break;
                    case 'pwd': this.cmdPwd(); break;
                    case 'mkdir': this.cmdMkdir(params); break;
                    case 'touch': this.cmdTouch(params); break;
                    case 'rm': this.cmdRm(params); break;
                    case 'cp': this.cmdCp(params); break;
                    case 'mv': this.cmdMv(params); break;
                    case 'echo': this.cmdEcho(params); break;
                    case 'grep': this.cmdGrep(params); break;
                    case 'head': this.cmdHead(params); break;
                    case 'tail': this.cmdTail(params); break;
                    case 'wc': this.cmdWc(params); break;
                    case 'whoami': this.printLine(this.user); break;
                    case 'id': this.printLine(`uid=1000(guest) gid=1000(guest) groups=1000(guest)`); break
                    case 'date': this.printLine(new Date().toString()); break;
                    case 'uptime': this.cmdUptime(); break;
                    case 'uname': this.cmdUname(params); break;
                    case 'history': this.cmdHistory(); break;
                    case 'man': this.cmdMan(params); break;
                    case 'sudo': this.printLine(`[sudo] password for ${this.user}:`); setTimeout(()=>this.printLine("Sorry, try again."), 1000); break;
                    case 'exit': this.printLine("logout"); this.inputArea.style.display = 'none'; break;
                    default:
                        this.printLine(`webterm: command not found: ${cmd}`, 'boot-error');
                }
                
                this.updatePrompt();
                this.scrollToBottom();
            }

            printLine(html, className = '') {
                const div = document.createElement('div');
                div.className = 'output-line ' + className;
                div.innerHTML = html;
                this.outputEl.appendChild(div);
            }

            scrollToBottom() {
                // Ensure DOM update handles new height
                setTimeout(() => {
                    window.scrollTo(0, document.body.scrollHeight);
                    document.getElementById('terminal-container').scrollTop = document.getElementById('terminal-container').scrollHeight;
                }, 10);
            }

            // --- COMMANDS ---

            cmdHelp() {
                const cmds = [
                    ['ls [-la]', 'List directory contents'],
                    ['cd [dir]', 'Change directory'],
                    ['cat [file]', 'Print file content'],
                    ['cp [src] [dst]', 'Copy file'],
                    ['mv [src] [dst]', 'Move/Rename file'],
                    ['rm [name]', 'Remove file or directory'],
                    ['mkdir [dir]', 'Create directory'],
                    ['touch [file]', 'Create empty file'],
                    ['grep [str] [file]', 'Search pattern in file'],
                    ['head [file]', 'Output first 10 lines'],
                    ['tail [file]', 'Output last 10 lines'],
                    ['wc [file]', 'Line, word, and byte count'],
                    ['pwd', 'Print working directory'],
                    ['echo [text]', 'Display a line of text'],
                    ['whoami', 'Print current user'],
                    ['uptime', 'Show system uptime'],
                    ['uname [-a]', 'Print system information'],
                    ['history', 'Show command history'],
                    ['man [cmd]', 'Show manual for command'],
                    ['clear', 'Clear terminal screen']
                ];
                
                let html = 'Available commands:<br><br>';
                html += '<div style="display: grid; grid-template-columns: 150px auto; gap: 5px;">';
                cmds.forEach(c => {
                    html += `<div style="color: var(--cmd-color); font-weight: bold;">${c[0]}</div><div>${c[1]}</div>`;
                });
                html += '</div>';
                this.printLine(html);
            }

            cmdClear() {
                this.outputEl.innerHTML = '';
            }

            cmdEcho(params) {
                this.printLine(params.join(' '));
            }

            cmdPwd() {
                this.printLine('/' + this.fs.currentPath.join('/'));
            }

            cmdLs(params) {
                let targetPath = '.';
                let showAll = false;
                let longFormat = false;

                // Parse flags
                const cleanParams = [];
                params.forEach(p => {
                    if (p.startsWith('-')) {
                        if (p.includes('a')) showAll = true;
                        if (p.includes('l')) longFormat = true;
                    } else {
                        cleanParams.push(p);
                    }
                });

                if (cleanParams.length > 0) targetPath = cleanParams[0];

                const res = this.fs.resolve(targetPath);
                if (!res || !res.node) {
                    this.printLine(`ls: cannot access '${targetPath}': No such file or directory`, 'boot-error');
                    return;
                }
                if (res.node.type !== 'dir') {
                    this.printLine(res.name); 
                    return;
                }

                const children = res.node.children;
                let names = Object.keys(children).sort();
                
                if (!showAll) {
                    names = names.filter(n => !n.startsWith('.'));
                } else {
                    names = ['.', '..', ...names];
                }

                if (longFormat) {
                    let html = '<div class="ls-l-row" style="border-bottom: 1px solid #30363d; margin-bottom:5px;"><span>PERMS</span><span>LNK</span><span>USER</span><span>GRP</span><span>SIZE</span><span>DATE</span><span>NAME</span></div>';
                    names.forEach(name => {
                        let node;
                        if(name === '.') node = res.node;
                        else if(name === '..') node = this.fs.resolve(targetPath + '/..').node; // simplistic
                        else node = children[name];
                        
                        if(!node) return;

                        let colorClass = node.type === 'dir' ? 'ls-dir' : 'ls-file';
                        if (node.type === 'file' && node.perms.includes('x')) colorClass = 'ls-exec';

                        html += `<div class="ls-l-row">
                            <span>${node.perms}</span>
                            <span>1</span>
                            <span>${node.user}</span>
                            <span>${node.group}</span>
                            <span>${node.size}</span>
                            <span>${node.date}</span>
                            <span class="${colorClass}">${name}</span>
                        </div>`;
                    });
                    this.printLine(html);
                } else {
                    const spans = names.map(name => {
                        let node;
                        if(name === '.') node = res.node;
                        else if(name === '..') node = res.node; // Hack for display
                        else node = children[name];

                        let className = 'ls-file';
                        if (node && node.type === 'dir') className = 'ls-dir';
                        if (node && node.type === 'file' && node.perms.includes('x')) className = 'ls-exec';
                        return `<span class="${className}" style="margin-right: 15px;">${name}</span>`;
                    });
                    this.printLine(spans.join(''));
                }
            }

            cmdCd(params) {
                if (params.length === 0) {
                    this.fs.currentPath = ['home', 'guest'];
                    return;
                }
                const target = params[0];
                const res = this.fs.resolve(target);

                if (!res || !res.node) {
                    this.printLine(`cd: ${target}: No such file or directory`, 'boot-error');
                } else if (res.node.type !== 'dir') {
                    this.printLine(`cd: ${target}: Not a directory`, 'boot-error');
                } else {
                    this.fs.currentPath = res.pathArr;
                }
            }

            cmdCat(params) {
                if (params.length === 0) return;
                
                params.forEach(file => {
                    const res = this.fs.resolve(file);
                    if (!res || !res.node) {
                        this.printLine(`cat: ${file}: No such file or directory`, 'boot-error');
                    } else if (res.node.type === 'dir') {
                        this.printLine(`cat: ${file}: Is a directory`, 'boot-error');
                    } else {
                        this.printLine(res.node.content.replace(/\n/g, '<br>').replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;'));
                    }
                });
            }

            cmdMkdir(params) {
                if (params.length === 0) { this.printLine("mkdir: missing operand"); return; }
                params.forEach(name => {
                    const { parentRes, childName } = this.fs.getParent(name);
                    if (!parentRes || !parentRes.node) {
                        this.printLine(`mkdir: cannot create directory '${name}': No such file or directory`, 'boot-error');
                    } else if (parentRes.node.children[childName]) {
                        this.printLine(`mkdir: cannot create directory '${name}': File exists`, 'boot-error');
                    } else {
                        const now = new Date();
                        const dateStr = now.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                        parentRes.node.children[childName] = { 
                            type: 'dir', perms: 'drwxr-xr-x', user: this.user, group: this.user, size: 4096, date: dateStr, children: {} 
                        };
                    }
                });
            }

            cmdTouch(params) {
                if (params.length === 0) { this.printLine("touch: missing operand"); return; }
                params.forEach(name => {
                    const { parentRes, childName } = this.fs.getParent(name);
                    if (!parentRes || !parentRes.node) return;
                    
                    const now = new Date();
                    const dateStr = now.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });

                    if (!parentRes.node.children[childName]) {
                        parentRes.node.children[childName] = { 
                            type: 'file', perms: '-rw-r--r--', user: this.user, group: this.user, size: 0, date: dateStr, content: '' 
                        };
                    } else {
                        // Update time
                        parentRes.node.children[childName].date = dateStr;
                    }
                });
            }

            cmdRm(params) {
                if (params.length === 0) { this.printLine("rm: missing operand"); return; }
                params.forEach(name => {
                    // Ignore flags for now
                    if(name.startsWith('-')) return;

                    const { parentRes, childName } = this.fs.getParent(name);
                    if (!parentRes || !parentRes.node || !parentRes.node.children[childName]) {
                        this.printLine(`rm: cannot remove '${name}': No such file or directory`, 'boot-error');
                        return;
                    }
                    // In a real rm, we'd check if it's a dir and require -r. 
                    // For simplicity, we'll allow deleting anything.
                    delete parentRes.node.children[childName];
                });
            }

            cmdCp(params) {
                if (params.length < 2) { this.printLine("cp: missing file operand"); return; }
                const srcStr = params[0];
                const dstStr = params[1];

                const srcRes = this.fs.resolve(srcStr);
                if(!srcRes || !srcRes.node) {
                    this.printLine(`cp: cannot stat '${srcStr}': No such file or directory`, 'boot-error');
                    return;
                }
                if(srcRes.node.type === 'dir') {
                    this.printLine(`cp: -r not implemented`, 'boot-error');
                    return;
                }

                const { parentRes, childName } = this.fs.getParent(dstStr);
                if (!parentRes || !parentRes.node) {
                    this.printLine(`cp: cannot create regular file '${dstStr}': No such file or directory`, 'boot-error');
                    return;
                }

                // Deep copy object
                const newNode = JSON.parse(JSON.stringify(srcRes.node));
                newNode.date = new Date().toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                
                // Check if dest is a dir
                const destExists = parentRes.node.children[childName];
                if(destExists && destExists.type === 'dir') {
                    destExists.children[srcRes.name] = newNode;
                } else {
                    parentRes.node.children[childName] = newNode;
                }
            }

            cmdMv(params) {
                if (params.length < 2) { this.printLine("mv: missing operand"); return; }
                const srcStr = params[0];
                const dstStr = params[1];

                const srcRes = this.fs.resolve(srcStr);
                const { parentRes: srcParent, childName: srcName } = this.fs.getParent(srcStr);

                if(!srcRes || !srcRes.node) {
                    this.printLine(`mv: cannot stat '${srcStr}': No such file or directory`, 'boot-error');
                    return;
                }

                const { parentRes: dstParent, childName: dstName } = this.fs.getParent(dstStr);
                
                if (!dstParent || !dstParent.node) {
                    this.printLine(`mv: cannot move '${dstStr}': No such file or directory`, 'boot-error');
                    return;
                }

                // Check if dest is a dir
                const destExists = dstParent.node.children[dstName];
                if(destExists && destExists.type === 'dir') {
                    // Move into directory
                    destExists.children[srcName] = srcRes.node;
                } else {
                    // Rename/Move to file
                    dstParent.node.children[dstName] = srcRes.node;
                }

                // Remove from source
                delete srcParent.node.children[srcName];
            }

            cmdGrep(params) {
                if(params.length < 2) { this.printLine("grep: usage: grep [pattern] [file]"); return; }
                const pattern = params[0];
                const file = params[1];
                
                const res = this.fs.resolve(file);
                if(!res || !res.node || res.node.type !== 'file') {
                    this.printLine(`grep: ${file}: No such file`, 'boot-error');
                    return;
                }

                const lines = res.node.content.split('\n');
                lines.forEach(line => {
                    if(line.includes(pattern)) {
                        // Highlight match
                        const regex = new RegExp(`(${pattern})`, 'g');
                        const hl = line.replace(regex, '<span style="color:red; font-weight:bold;">$1</span>');
                        this.printLine(hl);
                    }
                });
            }

            cmdHead(params) {
                if(params.length === 0) return;
                const res = this.fs.resolve(params[0]);
                if(res && res.node && res.node.type === 'file') {
                    const lines = res.node.content.split('\n').slice(0, 10);
                    this.printLine(lines.join('\n'));
                }
            }

            cmdTail(params) {
                if(params.length === 0) return;
                const res = this.fs.resolve(params[0]);
                if(res && res.node && res.node.type === 'file') {
                    const lines = res.node.content.split('\n');
                    const start = Math.max(0, lines.length - 10);
                    this.printLine(lines.slice(start).join('\n'));
                }
            }

            cmdWc(params) {
                if(params.length === 0) return;
                const res = this.fs.resolve(params[0]);
                if(res && res.node && res.node.type === 'file') {
                    const content = res.node.content;
                    const lines = content.split('\n').length;
                    const words = content.split(/\s+/).filter(w => w.length > 0).length;
                    const bytes = content.length;
                    this.printLine(`${lines} ${words} ${bytes} ${params[0]}`);
                }
            }

            cmdUptime() {
                const now = new Date();
                const diff = Math.floor((now - this.startTime) / 1000); // seconds
                const hours = Math.floor(diff / 3600);
                const mins = Math.floor((diff % 3600) / 60);
                this.printLine(`${now.toLocaleTimeString()} up ${hours}h ${mins}m, 1 user, load average: 0.00, 0.01, 0.05`);
            }

            cmdUname(params) {
                if(params.includes('-a')) {
                    this.printLine("Linux webterm 5.4.0-webterm #1 SMP Fri Nov 21 00:00:00 UTC 2025 x86_64 GNU/Linux");
                } else {
                    this.printLine("Linux");
                }
            }

            cmdHistory() {
                this.history.forEach((cmd, i) => {
                    this.printLine(`  ${i + 1}  ${cmd}`);
                });
            }

            cmdMan(params) {
                if(params.length === 0) { this.printLine("What manual page do you want?"); return; }
                const cmd = params[0];
                
                const manuals = {
                    'ls': { name: 'ls', desc: 'list directory contents', synopsis: 'ls [OPTION]... [FILE]...', flags: '-a, --all: do not ignore entries starting with .\n-l: use a long listing format' },
                    'cd': { name: 'cd', desc: 'change the shell working directory', synopsis: 'cd [dir]', flags: 'None' },
                    'cp': { name: 'cp', desc: 'copy files and directories', synopsis: 'cp [SOURCE] [DEST]', flags: 'None' },
                    'mv': { name: 'mv', desc: 'move (rename) files', synopsis: 'mv [SOURCE] [DEST]', flags: 'None' },
                    'grep': { name: 'grep', desc: 'print lines matching a pattern', synopsis: 'grep [PATTERN] [FILE]', flags: 'None' },
                    'cat': { name: 'cat', desc: 'concatenate files and print on the standard output', synopsis: 'cat [FILE]...', flags: 'None' }
                };

                const page = manuals[cmd];
                if(page) {
                    this.printLine(`<span class="man-header">NAME</span>\n    ${page.name} - ${page.desc}`);
                    this.printLine(`<span class="man-header">SYNOPSIS</span>\n    ${page.synopsis}`);
                    this.printLine(`<span class="man-header">DESCRIPTION</span>\n    ${page.flags}`);
                } else {
                    this.printLine(`No manual entry for ${cmd}`);
                }
            }

            handleTabCompletion() {
                const currentVal = this.inputEl.value;
                const parts = currentVal.split(' ');
                const partial = parts[parts.length - 1];
                
                // Get CWD items
                const cwdRes = this.fs.resolve('.');
                const candidates = Object.keys(cwdRes.node.children).filter(n => n.startsWith(partial));

                if (candidates.length === 1) {
                    parts[parts.length - 1] = candidates[0];
                    this.inputEl.value = parts.join(' ');
                } else if (candidates.length > 1) {
                    // Print possibilities
                    const promptHTML = this.promptLabel.innerHTML;
                    this.printLine(`${promptHTML} ${currentVal}`);
                    this.printLine(candidates.join('  '));
                    this.scrollToBottom();
                }
            }
        }

        const term = new Terminal();
        function focusInput() { document.getElementById('cmd-input').focus(); }
    </script>
</body>
</html>